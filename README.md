# Вопросы на собесах Frontend (CSS, JS and React)

# CSS
<details>
<summary>1. В чем разница - display, visibility, opacity?</summary>

##
- display

Многоцелевое свойство, которое определяет, как элемент должен быть показан в документе.

- visibility

Предназначен для отображения или скрытия элемента, включая рамку вокруг него и фон. При скрытии элемента, хотя он и становится не виден, место, которое элемент занимает, остается за ним

- opacity

Определяет уровень прозрачности элемента веб-страницы. При частичной или полной прозрачности через элемент проступает фоновый рисунок или другие элементы, расположенные ниже полупрозрачного объекта.
##
</details>

<details>
<summary>2. Box-sizing и Border-box - что за свойства?</summary>

##
- box-sizing

Применяется для изменения алгоритма расчета ширины и высоты элемента.
```css
box-sizing: border-box;
```
На ширину блока не влияет padding и border.
##
</details>

<details>
<summary>3. position: sticky - как работает?</summary>

##
```css
position: fixed;
```
Элемент удаляется из обычного потока документа и становится выше всех других элементов обычного потока. Элемент будет всегда находится в зоне просмотра (viewport) браузера и позиционироваться относительно зоны просмотра. Положение элемента можно изменять используя свойства top, right, bottom, left и z-index.

```css
position: sticky;
```
Элемент остается в обычном потоке документа, а затем "прилипает" к ближайшему родителю с прокруткой и скроллится вместе с ним. В народе это называют "липким" элементом, который прилипает к верху экрана при прокрутке, когда прокрутка достигает этого элемента.
##
</details>

<details>
<summary>4. Какие существуют псевдоэлементы?</summary>

##
- :after, :before

создает псевдоэлемент, который является последним (:after) или первым (:before) потомком элемента. Обычно используется для создания декоративных элементов для выбранного элемента.

- :placeholder 

Псевдоэлемент позволяет стилизовать текст, который был вставлен используя атрибут placeholder для элементов форм, таких как ``input`` и ``textarea``

- :first-child, :last-child

Псевдокласс позволяет стилизовать первый или последний дочерний элемент какого-либо блока.

- :focus

Псевдокласс применяется когда человек взаимодействует с элементом форм (``form``) такими как ``input, textarea, select, button`` и ссылки. Активируется при клике мышью пользователем по элементу. При фокусе на элементе появляется обводка (``outline``) по умолчанию

- :hover

Псевдокласс срабатывает в момент наведения курсора мыши на элемент.

- :visited

Псевдокласс позволяет стилизовать посещенные ссылки.

- :active

Псевдокласс срабатывает в момент нажатия левой кнопки мыши на элемент.
##
</details>

<details>
<summary>5. Tag picture - как применять?</summary>

##
Контейнер в котором должен быть один тег `img` и элементы `source` с разными источниками и условиями отображения. Браузер подберет подходящее изображение из элемента `source` или использует источник в теге `img`, если подходящего источника не было найдено.

```css
<picture>
    <source media="(max-width: 650px)" srcset="https://htmlbase.ru/storage/app/media/travel-mobile.jpg"></source>
    <img src="https://htmlbase.ru/storage/app/media/travel.jpg" alt=""></img>
</picture>
```
##
</details>

<details>
<summary>6. Что такое Pixel Perfect?</summary>

##
Pixel Perfect — это подход в вёрстке, когда итоговый результат максимально точно, пиксель в пиксель, совпадает с дизайнерским макетом. Для этого макет сайта сохраняется как обычная картинка, после чего эта картинка накладывается поверх свёрстанного сайта при помощи специальных инструментов, например, браузерных расширений. После наложения становится очевидной разница, если она есть, между тем, как нарисовал дизайнер, и тем, что получилось в итоге.
##
</details>

---

# JavaScript
<details>
<summary>1. Что такое замыкание?</summary>

##
При создании функции и использования внутри нее переменных, эти переменные доступны только локально внутри функции. Снаружи мы не можем получить к ним доступ. На хранение таких переменных в том числе и аргументов выделяется определенная память и когда функция заканчивает свое выполнение это память очищается. Таким образом эти переменные больше не где не существуют.

Но вот если внутри одной функции создать вторую то вложенная функция получит доступ к переменным которые были объявлены во внешней функции этот механизм
и называется замыканием т е вложенная функция замыкает на себе переменные и аргументы внешней функции.

Таким образом при отработке внешней функции возвращается внутренняя которая замыкается на значения внешней и не дает памяти очистится 

Где используется: если нужно создать приватные переменные внутри другой функции. Конфиденциальность данных / эмуляция скрытых методов при помощи замыканий. Обычно используется в модульном паттерне.

Замыкание технически включает три компонента:

- внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные - лексическое окружение
- переменные (лексическое окружение), которые определены во внешней функции
- вложенная функция, которая использует эти переменные
```js
function outer(){         // внешняя функция
    let x = 5;            // некоторая переменная          
    function inner(){     // вложенная функция
        console.log(x++); // действия с переменной x
    };
    return inner;
}
let fn = outer();   // fn = inner, так как функция outer возвращает функцию inner, 
// переменная fn будет хранить ссылку на функцию inner. 
// При этом эта функция запомнила свое окружение - то есть внешнюю переменную x.
// вызываем внутреннюю функцию inner
fn();   // 5
fn();   // 6
fn();   // 7
let newFn = outer();  // здесь также в переменной newFn хранится ссылка
// на функцию inner и содержит уже новое значение, начиная со значения 5
newFn() // 5
newFn() // 6
```
##
</details>

<details>
<summary>2. Что такое цикл событий (event loop) и как он работает?</summary>

##
Так как движок Node.js одопоточный т.е выполнение каких либо задач выполняется по очереди один за другим.

При вызове какой-то функции она попадает в так называемый стек вызовов.В стеке вызовов хранятся функции, до которых дошёл интерпретатор, и которые надо выполнить. После выполнения всего блока (разных функции к примеру) стек станет пустым. В синхронном коде в стеке хранится вся цепочка вызовов.

Управление тем, как должны вызываться асинхронные операции, берёт на себя цикл событий (Event loop).

Цикл событий отвечает за выполнение кода, сбор и обработку событий и выполнение подзадач из очереди.
```
Стек вызовов => Web API => Очередь задач
Очередь задач => Стек вызовов
```
- **Стек вызовов** - "первым пришел, последним вышел" или "последним пришел, первым вышел", что то же самое.
- **Очередь задач** - "первым пришел, первым ушел".
##
</details>

<details>
<summary>3. Контекст (this)</summary>

## 
this - это специальная переменная, которая ссылается, на тот объект, в котором она на данный момент находится.

```js
let obj = {
   model: "toyota",
   year: 2017,
   show: function() {
   console.log(this.model) // obj.model
   }
 };
obj.show()
```
##
</details>

<details>
<summary>4. В чем разница между null и undefined?</summary>

##
Оба варианта означают пустое значение. Если мы инициализируем
переменную, но не присваиваем ей значение, туда помещается специальный
«маркер», который отображается при выводе на экран как undefined. Null
присваиваем самостоятельно.

Null - Это просто специальное значение, которое представляет собой «ничего»,
«пусто» или «значение неизвестно». Если необходимо очистить значение
переменной, мы делаем q = null.
undefined означает, что «значение не было присвоено».
##
</details>

<details>
<summary>5. Стрелочные функции и их отличие от функций, объявленных через function</summary>

## 
- Стрелочные функции не имеют argumemts.
- Синтаксис
- У стрелочных функций нет своего this. Если идет обращение к this, то он
берется снаружи.
- Не могут быть функциями – конструкторами. Т.е не могут вызываться с
помощью new
- Cтрелочную функцию можно написать в одну строку без объявления слова return
##
</details>

<details>
<summary>6. Что такое set и map?</summary>

##
Map – это коллекция, структура данных, работающая по принципу
ключ/значение, как и Object. Но основное отличие от объекта в том, что Map
позволяет использовать ключи любого типа.

Объект Set – это особый вид коллекции: «множество» значений (без ключей),
своего рода массив, где каждое значение может появляться только один раз.
##
</details>

<details>
<summary>7. Какие значения являются falsy (ложными) значениями?</summary>

##
Falsy значение – значение, которое при приведении к логическому типу
возвращает false.

```js
console.log(false)
console.log(0)
console.log('')
console.log(undefined)
console.log(null)
console.log(NaN)
console.log(BigInt(0))
```
##
</details>

<details>
<summary>8. Что такое Promise?</summary>

##
Промис (Promise) — специальный объект JavaScript, который используется для написания и обработки асинхронного кода.

Асинхронные функции возвращают объект Promise в качестве значения. Внутри промиса работает асинхронная операция, которая управляет его состоянием.\
Промисы были придуманы для решения проблемы так называемого «ада функций обратного вызова».

Промис может находиться в одном из трёх состояний:

- pending — стартовое состояние, операция стартовала;
- fulfilled — получен результат;
- rejected — ошибка.

Поменять состояние можно только один раз: перейти из pending либо в fulfilled, либо в rejected:

У промиса есть методы then() и catch(), которые позволяют выполнять код при изменении его состояния.
##
</details>

<details>
<summary>9. Что такое async/await?</summary>

##
Async/await — относительно новый способ написания асинхронного (неблокирующего) кода в JS. Им оборачивают промис. Он делает код более читаемым и чистым, чем промисы и функции обратного вызова.\
Функция, обозначенная как async всегда вернет Promise.

Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока
промис справа от await не выполнится. После чего оно вернёт его результат, и
выполнение кода продолжится. await нельзя использовать в обычных функциях
##
</details>

<details>
<summary>10. Для чего нужен оператор spread?</summary>

##
Спред-синтаксис (spread) ... позволяет передавать итерируемые коллекции (например, массивы или строки) как список аргументов функции или добавлять содержащиеся в них элементы в новый массив.

Спред применятся и для объектов, чтобы копировать пары ключ-значение из одного объекта в другой.

- При вызове функции использовать значения из массива как аргументы:
```js
function multiplyThreeNumbers(a, b, c) {
  return a * b * c
}

const nums = [1, 2, 3]

console.log(multiplyThreeNumbers(...nums)) // 6
```

- В массиве скопировать элементы из другого массива в новый:

```js
const donor = ['это', 'старые', 'значения']
const newArray = [...donor, 1, true, 'мама']

console.log(newArray) // ['это', 'старые', 'значения', 1, true, 'мама']
```

- У объекта скопировать свойства из другого объекта в новый:

```js
const persona = { name: 'Иван', lastName: 'Объектов'}
const userData = { ...persona, username: 'killer3000' }

console.log(userData)
// {
//    name: 'Иван',
//    lastName: 'Объектов',
//    username: 'killer3000'
// }
```
Если в массиве будет больше элементов, чем параметров функции, то будут использованы только те элементы, которые идут первыми по порядку:

```js
function multiplyThreeNumbers(a, b, c) {
  return a * b * c
}

const nums = [1, 2, 3, 5, 6]

console.log(multiplyThreeNumbers(...nums)) // 6
```
##
</details>

<details>
<summary>11. Поверхностное и глубокое копирование</summary>

##
При копировании объектов или массивов JavaScript копирует данные только на один уровень вглубь. Этот тип копирования называется поверхностным (shallow).

Если необходимо полностью скопировать сложную структуру данных, например, массив с объектами, то нужно делать глубокое (deep) или полное копирование данных. JavaScript не содержит функций для глубокого копирования, лучший вариант сделать глубокую копию — сериализовать структуру в JSON и тут же распарсить.

- Поверхностное копирование
---
```
const copy = {…obj}
```
- Глубокое копирование
---
1. Воспользоваться костыльным, медленным способом:
```js
const copy = JSON.parse(JSON.stringify(obj))
```
Такой способ подойдет для объекта без прототипа и без функций.

2. реализовать рекурсивную функцию копирования полей.
3. Воспользоваться библиотекой lodash, функцией deep clone
##
</details>

<details>
<summary>12. Что такое деструктуризация?</summary>

##
В JavaScript есть две чаще всего используемые структуры данных – это Object
и Array. Деструктурирующее присваивание – это специальный синтаксис, который
позволяет нам «распаковать» массивы или объекты в кучу переменных, так как
иногда они более удобны.
##
</details>

<details>
<summary>13. Что такое DOM дерево?</summary>

##
DOM (Document Object Model) — это специальная древовидная структура, которая позволяет управлять HTML-разметкой из JavaScript-кода. Управление обычно состоит из добавления и удаления элементов, изменения их стилей и содержимого.

Браузер создаёт DOM при загрузке страницы, складывает его в переменную document и сообщает, что DOM создан, с помощью события DOMContentLoaded. С переменной document начинается любая работа с HTML-разметкой в JavaScript.
##
</details>

<details>
<summary>14. Всплытие и погружение событий</summary>

##
- Всплытие.

Принцип всплытия очень простой. Когда на элементе происходит событие,
обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так
далее, вверх по цепочке предков.

- Погружение

Стандарт DOM Events описывает 3 фазы прохода события:
1. Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
2. Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
3. Фаза всплытия (bubbling stage) – событие начинает всплывать.
##
</details>

<details>
<summary>15. Для чего нужны полифилы?</summary>

##
«Полифил» – это библиотека, которая добавляет в старые
браузеры поддержку возможностей, которые в современных браузерах являются
встроенными.
##
</details>

<details>
<summary>16. Расскажите о функциях - конструкторах</summary>

## 
Функции-конструкторы являются обычными функциями. Но есть два
соглашения:
1. Имя функции-конструктора должно начинаться с большой буквы.
2. Функция-конструктор должна вызываться при помощи оператора "new".
```js
function User() {
  this.name = 'Alex'
}

const firstUser = new User()
firstUser.name === 'Alex' // true
```
Когда функция вызывается как new User(...), происходит следующее:
1. Создаётся новый пустой объект, и он присваивается this.
2. Выполняется код функции. Обычно он модифицирует this, добавляет туда
новые свойства.
3. Возвращается значение this
##
</details>

<details>
<summary>17. Микро и макро таски в JavaScript</summary>

##
- MicroTask - Promises ... выполняються раньше 
- MacroTask - SetTimeout ... выполняються позже
##
</details>

<details>
<summary>18. Что представляет из себя чистая функция?</summary>

##
Функция должна удовлетворять двум условиям, чтобы считаться «чистой»
- Каждый раз функция возвращает одинаковый результат, когда
вызывается с тем же набором аргументов
- Нет побочных эффектов (например, не изменяет внешние переменные)
##
</details>

<details>
<summary>19. Что представляет из себя функция высшего порядка?</summary>

##
Функция высшего порядка — это функция, которая может принимать другую
функцию в качестве аргумента или возвращать другую функцию в качестве
результата
##
</details>

<details>
<summary>20. Ссылочные типы данных в js?</summary>

##
Все типы данных JavaScript можно разделить на примитивные и ссылочные.

- Объекты как ссылочные типы

Одно из фундаментальных отличий объектов от примитивов заключается в том, что объекты хранятся и копируются «по ссылке», тогда как примитивные значения: строки, числа, логические значения и т.д. – всегда копируются «как целое значение».

Переменная, которой присвоен объект, хранит не сам объект, а его «адрес в памяти» – другими словами, «ссылку» на него.

При копировании переменной объекта копируется ссылка, но сам объект не дублируется.

```js
let x = [10, 9, 8];
let y = x;
x[0] = 2;

console.log(y[0]); // 2
```

- Передача объектов функциям

Когда следует уделять особое внимание ссылочным типам, возникает при передаче их в виде аргументов функциям. Ввиду того что ссылочные типы содержат ссылки на соответствующие реальные данные, аргументы функции получают копию ссылки на данные и могут, таким образом, менять оригинальные данные.

- Сравнение объектов

При использовании операции проверки равенства (==) интерпретатор сравнивает значения соответствующих переменных. Для примитивных типов это означает сравнение фактических данных.

В случае ссылочных типов переменные содержат ссылки на данные, а не сами данные. Поэтому при использовании операции проверки равенства происходит сравнение ссылок, а не объектов, на которые эти ссылки указывают. Другими словами, операция == обеспечивает проверку не того, что две переменные ссылаются на эквивалентные объекты, а того, что переменные ссылаются на один и тот же объект.

```js
var str1 = new String("abc");
var str2 = new String("abc");

console.log(strl == str2); // false
```
##
</details>

<details>
<summary>21. Cookie, localStorage и sessionStorage?</summary>

##
Существует несколько подходов к хранению данных в браузере:

1. LocalStorage, SessionStorage - это интерфейс взаимодействия с хранилищем.

**SessionStorage** похож на краткосрочные Cookie, потому что данные в этом хранилище хранятся только во время жизни текущей сессии.

**LocalStorage**, в теории, является бессрочным хранилищем данных.

- Позволяют хранить пары ключ/значение в браузере.
- Максимальный объем хранимых данных — 5 Мб.
- Что в них важно – данные, которые в них записаны, сохраняются после
обновления страницы.

Оба хранилища в качестве ключей и значений могут использовать только
строки, поэтому объекты не забываем преобразовывать с помощью JSON.stringify.

2. **Cookie** – это небольшие строки данных, которые хранятся непосредственно в браузере. Данные, хранящиеся в куках, также передаются на сервер в виде HTTP-заголовка и могут быть им изменены. 

У хранения данных в **Cookie** есть много ограничений.

- они передаются при каждом запросе к серверу.
- их размер ограничен 4096 байтами. 
- срок хранения данных по умолчанию ограничен длинной сессии.

Куки обычно устанавливаются веб-сервером при помощи заголовка Set-Cookie. 
Мы также можем получить доступ к куки непосредственно из браузера, используя свойство document.cookie.

Один из наиболее частых случаев использования куки – это **аутентификация**:

- При входе на сайт сервер отсылает в ответ HTTP-заголовок Set-Cookie для того, чтобы установить куки со специальным уникальным идентификатором сессии («session identifier»).
- Во время следующего запроса к этому же домену браузер посылает на сервер HTTP-заголовок Cookie.
- Таким образом, сервер понимает, кто сделал запрос.
##
</details>

<details>
<summary>22. Что такое Intersection Observer API?</summary>

##
Intersection Observer API (IOA) позволяет приложению асинхронно наблюдать за пересечением элемента (target) с его родителем (root) или областью просмотра (viewport). Другими словами, этот API обеспечивает вызов определенной функции каждый раз при пересечении целевого элемента с root или viewport.

Примеры использования:

- «ленивая» или отложенная загрузка изображений
- бесконечная прокрутка страницы
- получение информации о видимости рекламы для целей расчета стоимости показов
- запуск процесса или анимации, находящихся в поле зрения пользователя

Для начала работы с IOA необходимо с помощью конструктора создать объект-наблюдатель с двумя параметрами — функцией обратного вызова и настройками

```js
// настройки
let options = {
    root: document.querySelector('.scroll-list'),
    rootMargin: '5px',
    threshold: 0.5
}

// функция обратного вызова
let callback = function(entries, observer){
    ...
}

// наблюдатель
let observer = new IntersectionObserver(callback, options)
```

Настройки:

- root — элемент, который выступает в роли области просмотра для target (предок целевого элемента или null для viewport)
- rootMargin — отступы вокруг root (margin в CSS, по умолчанию все отступы равны 0)
- threshold — число или массив чисел, указывающий допустимый процент пересечения target и root

Далее создается целевой элемент, за которым наблюдает observer:

```js
let target = document.querySelector('.list-item')
observer.observe(target)
```

Вызов callback возвращает объект, содержащий записи об изменениях, произошедших с целевым элементом:

```js
let callback = (entries, observer) => {
    entries.forEach(entry => {
        // entry (запись) - изменение
        //   entry.boundingClientRect
        //   entry.intersectionRatio
        //   entry.intersectionRect
        //   entry.isIntersecting
        //   entry.rootBounds
        //   entry.target
        //   entry.time
    })
}
```
##
</details>

<details>
<summary>23. Архитектура и паттерны проектирования в JavaScript? </summary>

##
В сфере разработки программного обеспечения паттерн проектирования — это повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

**Архитектура приложения** — это набор решений о том, как модули приложения будут общаться друг с другом и с внешним миром.

Архитектура включает в себя подходы: ограничения, правила и эвристики, которым надо следовать при написании кода.

Часто используемое решение: React/Redux, который использует однонаправленный поток данных на основе архитектуры Flux.

**Паттерн проектирования** — шаблонное решение частой архитектурной проблемы.

Область ответственности паттернов проектирования меньше, чем у архитектуры в целом. Паттерны помогают нам решать проблемы на более «низком уровне», ближе к непосредственно коду. Архитектура же решает проблемы проектирования всей системы в целом.

**Модули в ES6**.

Модули ES6 хранятся в файлах. Один файл может содержать лишь один модуль. Всё, что находится внутри модуля, по умолчанию является приватным. Функции, переменные и классы можно делать публичными с использованием ключевого слова export. Код внутри модуля всегда выполняется в строгом режиме.

Пример:
```js
export {multiply, divide};
import { sum, multiply } from './utils.js';
```

Виды паттернов:

- Фабрика

Фабрика создаёт объект, избавляя нас от необходимости знать детали создания.
Фабрика в программировании принимает от нас сигнал, что надо создать объект, и создаёт его, инкапсулируя логику создания внутри себя.

Пример:
```js
function createGuitar(stringsCount = 6) {
  return {
    strings: stringsCount,
    frets: 24,
    fretBoardMaterial: 'кедр',
    boardMaterial: 'клён',
  }
}
```

- Декоратор 

Декоратор позволяет динамически менять поведение объекта в рантайме. Используйте декораторы для выделения повторяющейся и расширяющей поведение объектов логики. Особенно это полезно для выделения кода, который можно использовать в разных модулях и задачах.

```js
const updateWithLogging = loggingDecorator(update)
updateWithLogging('Мария', 'test@test.com')
// Логирую... Мария, test@test.com
console.log(user)
// {name: 'Мария', email: 'test@test.com'}
```
##
</details>

<details>
<summary>24. Что такое инкремент/декремент? </summary>

##
Одной из наиболее частых числовых операций является увеличение или уменьшение на единицу.

Для этого существуют даже специальные операторы:

- **Инкремент** ++ увеличивает переменную на 1:
```js
let counter = 2;
counter++;        // работает как counter = counter + 1, просто запись короче
console.log( counter ); // 3
```
- **Декремент** -- уменьшает переменную на 1:
```js
let counter = 2;
counter--;        // работает как counter = counter - 1, просто запись короче
console.log( counter ); // 1
```
- Если результат оператора не используется, а нужно только увеличить/уменьшить переменную, тогда без разницы, какую форму использовать:
```js
let counter = 0;
counter++;
++counter;
console.log( counter ); // 2, обе строки сделали одно и то же
```
- Если хочется тут же использовать результат, то нужна префиксная форма:
```js
let counter = 0;
console.log( ++counter ); // 1
```
- Если нужно увеличить и при этом получить значение переменной до увеличения – нужна постфиксная форма:
```js
let counter = 0;
console.log( counter++ ); // 0
```
##
</details>

<details>
<summary>25. В чем разница между in vs hasOwnProperty ? </summary>

##
Метод hasOwnProperty() возвращает логическое значение, указывающее, содержит ли объект указанное свойство.

```js
obj.hasOwnProperty(prop)
```

Оператор in возвращает true, если свойство содержится в указанном объекте или в его цепочке прототипов.

```js
prop in object
```

Каждый объект, произошедший от `Object`, наследует метод `hasOwnProperty`. Этот метод может использоваться для определения того, содержит ли объект указанное свойство в качестве собственного свойства объекта; в отличие от оператора `in`, этот метод не проверяет существование свойств в цепочке прототипов объекта.
##
</details>

<details>
<summary>26. Что такое callback-функция?</summary>

##
коллбэк — это функция, которая должна быть выполнена после того, как другая функция завершила выполнение (отсюда и название: callback — функция обратного вызова). Любая функция, которая передается как аргумент, называется callback-функцией.
##
</details>

<details>
<summary>27. Что такое генераторы в javascript и как они работают?</summary>

##
Генераторы могут порождать (yield) множество значений одно за другим, по
мере необходимости. Генераторы отлично работают с перебираемыми объектами и
позволяют легко создавать потоки данных.

Для объявления генератора используется специальная синтаксическая
конструкция: function*, которая называется «функция-генератор»

```js
function* generateFuncion () {
   yield 1;
   yield 2;
   return 3;
}
```
Основным методом генератора является `next()`. При вызове он запускает
выполнение кода до ближайшей инструкции `yield` <значение> (значение может
отсутствовать, в этом случае оно предполагается равным `undefined`). По достижении
`yield` выполнение функции приостанавливается, а соответствующее значение –
возвращается во внешний код

```js
let generator = generateFuncion()
let one = generator.next()
```
##
</details>

<details>
<summary>28. Чем отличается PUT от PATCH?</summary>

##
PUT, выбирается из базы сущность и обновляются её поля, при чём все сразу.

PATCH, тоже самое, только обновляются не все поля, а выборочно.
##
</details>

<details>
<summary>29. Что такое HTTP и HTTPS?</summary>

##
HTTP — это протокол передачи данных (гипертекстовой разметки) между браузером и сервером: страниц, файлов, видеозаписей. HTTPS — это тот же HTTP, но с добавленными методами шифрования данных и проверки безопасности. Встретить сейчас ресурс на HTTP довольно сложно — им не доверяют ни пользователи, ни браузеры, ни поисковики.

Протоколы TLS (Transport Layer Security) — криптографические. Это значит, что они позволяют шифровать данные, в нашем случае те, что передаются между браузером и сервером. Расшифровать эти данные могут только сервер и браузер, для всех остальных это будет набор нечитаемых символов.
##
</details>

<details>
<summary>30. Из чего состоит тело запроса fetch?</summary>

##
Функция fetch() принимает два параметра:

- url — адрес, по которому нужно сделать запрос;
```js
fetch('http://jsonplaceholder.typicode.com/posts')
```
- options (необязательный) — объект конфигурации, в котором можно настроить метод запроса, тело запроса, заголовки и многое другое.
```js
fetch('https://jsonplaceholder.typicode.com/posts', {
  method: 'POST', // Здесь так же могут быть GET, PUT, DELETE
  body: JSON.stringify(newPost), // Тело запроса в JSON-формате
  headers: {
    // Добавляем необходимые заголовки
    'Content-type': 'application/json; charset=UTF-8',
  },
```
По умолчанию fetch() запросы не включают в себя cookies и потому авторизованные запросы на сервере могут не пройти. Для этого необходимо добавить в настройку поле credentials:
```js
fetch('https://somesite.com/admin', {
  method: 'GET',
  // или 'same-origin' если можно делать такие запросы только в пределах этого домена
  credentials: 'include',
})
```
##
</details>

<details>
<summary>31. Расскажите, как работает прототипное наследование</summary>

##
Все объекты в JavaScript имеют свойство __proto__, которое является ссылкой на другой объект. Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на одном из прототипов или до тех пор, пока он не достигнет конца цепочки прототипов.
##
</details>

<details>
<summary>32. В чем разница между методами preventDefault и stopPropagation?</summary>

##
Метод `preventDefault` отключает стандартную обработку события браузером, а метод `stopPropagation` - распространение события, т.е. запуск родительских по отношению к элементу, в котором возникло событие, обработчиков.

Например, "дефолтная" обработка события `submit` элемента `form` предполагает отправку данных формы и перезагрузку страницы.
```js
<form id="formEl">
  <input type="text" id="inputEl" />
  <button>Отправить</button>
</form>
```
```js
formEl.onsubmit = (e) => {
  e.preventDefault()
  alert(inputEl.value || 'hello world')
}
```
Событие поднимается от целевого элемента до `window` через всех его предков. Элементы, через которые проходит событие (путь события), содержится в свойстве `event.path`.
```js
<div id="outerBox">
  <div id="innerBox">
    <button id="firstButtonEl">Сначала нажми на меня</button>
    <button id="secondButtonEl">А потом на меня</button>
  </div>
</div>
```
```js
window.onclick = (e) => {
  console.log(`Событие #${e.eventNum} достигло объекта "window"`)
}
outerBox.onclick = (e) => {
  console.log(`Событие #${e.eventNum} достигло внешнего контейнера`)
}
innerBox.onclick = (e) => {
  console.log(`Событие #${e.eventNum} достигло внутреннего контейнера`)
}
firstButtonEl.onclick = (e) => {
  console.log('Возникло событие нажатия первой кнопки')
  e.eventNum = '1'
}
secondButtonEl.onclick = (e) => {
  // !
  e.stopPropagation()
  console.log('Возникло событие нажатия второй кнопки')
  e.eventNum = '2'
}
firstButtonEl.click()
/*
  Возникло событие нажатия первой кнопки
  Событие #1 достигло внутреннего контейнера
  Событие #1 достигло внешнего контейнера
  Событие #1 достигло объекта "window"
*/
secondButtonEl.click()
// Возникло событие нажатия второй кнопки
```
##
</details>

---

# React

<details>
<summary>1. Что такое VirtualDom</summary>

##
VirtualDOM это копия DOM дерева и вместо того, чтобы взаимодействовать с
DOM напрямую, мы работаем с его легковесной копией. Мы можем вносить
изменения в копию, исходя из наших потребностей, а после этого React применяет
изменения к реальному DOM.

При этом происходит сравнение DOM-дерева с его виртуальной копией,
определяется разница и запускается перерисовка того, что было изменено.

Такой подход работает быстрее, потому как не включает в себя все
тяжеловесные части реального DOM.
##
</details>

<details>
<summary>2. Разница между контролируемыми и неконтролируемыми компонентами</summary>

##
В **контролируемом** компоненте данные формы обрабатываются компонентом React. 
Альтернативой являются **неконтролируемые** компоненты, где данные формы обрабатываются самим DOM.

В HTML элементы формы, **такие как input, textarea и select**, обычно
поддерживают собственное состояние и обновляют его в соответствии с
пользовательскими входными данными. В React изменяемое состояние обычно
хранится в свойстве state компонентов и обновляется только с помощью setState().

Мы можем объединить всё это вместе, сделав состояние React «единственным
источником данных (истины)». Затем компонент React, который отрисовывает
форму, также контролирует, что происходит в этой форме при последующем вводе
данных пользователем. Элемент поля ввода формы, значение которого
контролируется React подобным образом, называется **«контролируемым
компонентом»**.

Вместо того, чтобы писать обработчик события для каждого обновления
состояния, вы можете использовать **неуправляемый** компонент и читать значения
из DOM через ref

Неуправляемые компоненты опираются на DOM в качестве источника данных и могут быть удобны при интеграции React с кодом, не связанным с React. Количество кода может уменьшиться, правда, за счёт потери в его чистоте. Поэтому в обычных ситуациях мы рекомендуем использовать управляемые компоненты.
##
</details>

<details>
<summary>3. Что такое жизненный цикл компонента React и какие методы знаете?</summary>

##
Каждый компонент React проходит несколько стадий в процессе своей жизни: он создаётся, затем добавляется в DOM, получает пропсы, и, наконец, удаляется из дерева. Этот процесс называют жизненным циклом компонента (Component Lifecycle). React предоставляет набор методов, которые позволяют встроиться в этот процесс.

Существует четыре различных этапа жизненного цикла компонента React:
1. Инициализация: На этом этапе компонент React готовит установку
начального состояния и параметров по умолчанию.
2. Монтирование: Компонент React готов для монтирования в DOM
браузера. Этот этап охватывает методы жизненного цикла
componentWillMount и componentDidMount.
3. Обновление: На этом этапе компонент обновляется двумя способами,
отправляя новые свойства и обновляя состояние. Этот этап охватывает
методы жизненного цикла shouldComponentUpdate, componentWillUpdate
и componentDidUpdate.
4. Размонтирование: На этом последнем этапе компонент не нужен и
отключается из DOM браузера. Этот этап включает метод жизненного
цикла componentWillUnmount.
##
</details>

<details>
<summary>4. Зачем хуки добавили в React?</summary>

##
С помощью хуков мы можем извлечь логику состояния из компонента, чтобы её протестировать или повторно использовать. Хуки позволяют нам повторно использовать логику состояния, не затрагивая дерево компонентов. Благодаря этому, хуки легко использовать в разных компонентах и делиться ими с сообществом (К примеру кастомные хуки для валидации форм). 

Хуки позволяют использовать состояние и другие функции жизненного цикла при использовании функциональных компонентов вместо классов. Меньше кода и повышая читабельность компонентов.
##
</details>

<details>
<summary>5. Что такое React хуки и какие вы знаете?</summary>

##
Хук — это специальная функция, которая позволяет «подцепиться» к возможностям
React.
Основные React хуки:
- useState;
- useEffect;
- useContext;
- useRef;
- useMemo;
- useCallback;
##
</details>

<details>
<summary>6. useState особенности использования</summary>

##
Хук useState предоставляет функциональным компонентам доступ к состоянию React.

Он возвращает значение с состоянием и функцию для его обновления.
Во время первоначального рендеринга возвращаемое состояние (state)
совпадает со значением, переданным в качестве первого аргумента (initialState).

Функция setState используется для обновления состояния. Она принимает новое
значение состояния и ставит в очередь повторный рендер компонента. Функция
setState может принимать параметром, как и новое значение, так и функцию callback,
которая параметром принимает предыдущее значение.
##
</details>

<details>
<summary>7. useEffect особенности использования</summary>

##
Хук эффекта даёт вам возможность выполнять побочные эффекты в
функциональном компоненте. useEffect - Мутации, подписки, таймеры, логирование
и другие побочные эффекты не допускаются внутри основного тела функционального компонента (называемого этапом рендеринга React). Это приведёт к запутанным
ошибкам и несоответствиям в пользовательском интерфейсе.

Вместо этого рекомендуется использовать useEffect. Функция, переданная в
useEffect, будет запущена после того, как рендер будет зафиксирован на экране или
же если передать вторым параметром массив зависимостей, то функция будет
вызываться каждый раз после изменения одной из зависимостей.
##
</details>

<details>
<summary>8. useLayoutEffect для чего нужен и когда использовать?</summary>

##
Главное же отличие от useEffect, заключается в том, что useLayoutEffect вызывается синхронно, после всех изменений в DOM. 

Используйте его для чтения макета из DOM и синхронного повторного рендеринга. Обновления, запланированные внутри useLayoutEffect, будут полностью применены синхронно перед тем, как браузер получит шанс осуществить отрисовку.

Предпочитайте стандартный useEffect, когда это возможно, чтобы избежать блокировки визуальных обновлений.

Одно из применений заключается в устранении мигания во время рендера компонента.
##
</details>

<details>
<summary>9. useContext для чего нужен и когда использовать?</summary>

##
В типичном React-приложении данные передаются сверху вниз (от родителя к
дочернему компоненту) с помощью пропсов. Однако, подобный способ
использования может быть чересчур громоздким для некоторых типов пропсов
(например, выбранный язык, UI-тема), которые необходимо передавать во многие
компоненты в приложении. Контекст предоставляет способ делиться такими
данными между компонентами без необходимости явно передавать пропсы через
каждый уровень дерева.

Компонент, вызывающий useContext, всегда будет перерендериваться при
изменении значения контекста. Если повторный рендер компонента затратен, вы
можете оптимизировать его с помощью мемоизации.
##
</details>

<details>
<summary>10. useRef для чего нужен и когда использовать?</summary>

##
useRef возвращает изменяемый ref-объект, свойство .current которого
инициализируется переданным аргументом (initialValue). Возвращённый объект будет сохраняться в течение всего времени жизни компонента и не будет изменяться
от рендера к рендеру.

Обычный случай использования — это доступ к потомку в императивном
стиле. Т.е. используя ref, мы можем явно обратиться к DOM элементу.

Пример использования:
```js
function TextInputWithFocusButton() {
  const inputEl = useRef(null);
  const onButtonClick = () => {
    // `current` указывает на смонтированный элемент `input`
    inputEl.current.focus();
  };
  return (
    <>
      <input ref={inputEl} type="text" />
      <button onClick={onButtonClick}>Установить фокус на поле ввода</button>
    </>
  );
}
```
##
</details>

<details>
<summary>11. useMemo для чего нужен и когда использовать?</summary>

##
useMemo используется для того, чтобы закешировать\замемоизировать результат вычислений.

Пример использования:
```js
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```
Предназначен для оптимизации проекта.
Этот хук возвращает не саму функцию, а результат её выполнения.
Таким образом, `useMemo` используется для сохранения результатов тяжёлых вычислений, например обработка массива. 

Передайте «создающую» функцию и массив зависимостей. `useMemo` будет
повторно вычислять мемоизированное значение только тогда, когда значение какой либо из зависимостей изменилось.

Первым параметром функция принимает callback, в котором проходят вычисления, а
вторым массив зависимостей, функция будет повторно проводить вычисления
только при изменении хотя бы одной из зависимостей
##
</details>

<details>
<summary>12. useCallback для чего нужен и когда использовать?</summary>

##
Хук useCallback вернёт мемоизированную версию колбэка, который
изменяется только, если изменяются значения одной из зависимостей. **Это полезно
при передаче колбэков оптимизированным дочерним компонентам, которые
полагаются на равенство ссылок для предотвращения ненужных рендеров.**

useCallback получает на функцию и массив аргументов, и возвращает одну и туже функцию, до тех пор, пока аргументы не изменились. **useCallback используется, когда важна постоянность ссылок на функцию.** 
##
</details>

<details>
<summary>13. Что такое JSX?</summary>

##
JSX — расширение синтаксиса JavaScript. Этот синтаксис выглядит как язык шаблонов, но наделён всеми языковыми возможностями JavaScript. В результате компиляции JSX и вызова React.createElement() возникают простые объекты — «React-элементы».

Это некое расширение языка упрощающее восприятие кода и разработку 
##
</details>

<details>
<summary>14. Что такое props?</summary>

##
Props (обьект js) – данные, которые передаются в компонент из родительского. Props
доступны только для чтения и не могут быть изменены.
##
</details>

<details>
<summary>15. React.memo для чего нужен и когда использовать?</summary>

##
React.memo — это компонент высшего порядка.

Если ваш компонент всегда рендерит одно и то же при неменяющихся
пропсах, вы можете обернуть его в вызов React.memo для повышения
производительности в некоторых случаях, мемоизируя тем самым результат. Это
значит, что React будет использовать результат последнего рендера, избегая
повторного рендеринга.

React.memo затрагивает только изменения пропсов. Если функциональный
компонент обёрнут в React.memo и использует useState, useReducer или useContext,
он будет повторно рендериться при изменении состояния или контекста.
##
</details>

<details>
<summary>16. Как работает проп children?</summary>

##
Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar, которые представляют из себя как бы «коробку», в которую можно что-то положить. Для таких компонентов мы рекомендуем использовать специальный проп children, который передаст дочерние элементы сразу на вывод
##
</details>

<details>
<summary>17. Что такое порталы в React?</summary>

##
Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента.

```js
ReactDOM.createPortal(child, container)
```

Первый аргумент (child) — это любой React-компонент, который может быть отрендерен, такой как элемент, строка или фрагмент. Следующий аргумент (container) — это DOM-элемент.

Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки.
##
</details>

<details>
<summary>18. Для чего нужен атрибут key при рендере списков?</summary>

##
Ключи (keys) помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени.

Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи. Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ.
##
</details>

<details>
<summary>19. Почему react не реактивен?</summary>

##
React назван так потому, что реагирует на изменения состояния компонентов. Все же он делает это не реактивно, а, скорее, по графику.

Помните, что входными данными для render() являются свойства (props) и внутреннее состояние, которое может быть обновлено в любое время.

Когда для render меняются входные данные, меняется и результат ее выполнения.

React.js ведет запись жизненного цикла компонента. Когда React.js видит, что один рендер отличается от другого, он переводит разницу между своим виртуальным представлением в операции с DOM API, которые будут отрисованы в документе.

Не отслеживает в реальном времени изменения переменных.
##
</details>

<details>
<summary>20. Что такое компонент React?</summary>

##
- Компонент React – это класс, который наследуется от класса React.Component 
- Функция render возвращает HTML разметку, то что будет отрисовано в браузере. Класс-компонент без функции render существовать не может, это его интерфейс.
##
</details>

---

# Redux

<details>
<summary>1. В каких случаях можно использовать локальное состояние, а в каких
лучше использовать глобальный State?</summary>

##
Локальное состояние рекомендуется использовать в тех случаях, когда оно
используется только в рамках 1го компонента и не планируется передавать его в
других компоненты. Также локальное состояние используется в компоненте какогото отдельного элемента списка. Если же декомпозиция на компоненты предполагает
вложенность с передачей данных по иерархии, то лучше использовать global state
##
</details>

<details>
<summary>2. Что такое редьюсер и какие параметры он принимает?</summary>

##
Reducer это чистая функция, которая принимает параметрами state и action.
Внутри редюсера мы отслеживаем тип полученного actions и в зависимости от него
мы изменяем состояние и возвращаем новый объект состояния.
##
</details>

<details>
<summary>3. Что такое экшен и как изменить состояние?</summary>

##
Action - это простой js объект, у которого обязательно должно быть поле с типом.
```js
{type: “SET_PAGE”}
```
Также опционально можно добавить какие-то данные. Для того что бы
изменить состояние необходимо вызвать функцию dispatch, в которую передаем
action.
##
</details>

<details>
<summary>4. Асинхронные actions в redux с помощью thunk?</summary>

##
Для того, чтобы использовать redux thunk необходимо подключить его как
middleware. Action creators должны возвращать не просто объект, а функцию, которая
параметром принимает dispatch.
##
</details>

<details>
<summary>5. Что такое Flux - архитектура? Какие сущности она имеет?</summary>

##
Flux-архитектура — архитектурный подход или набор шаблонов программирования для построения пользовательского интерфейса веб-приложений, сочетающийся с реактивным программированием и построенный на однонаправленных потоках данных.

Основной отличительной особенностью Flux является односторонняя направленность передачи данных между компонентами Flux-архитектуры. Архитектура накладывает ограничения на поток данных, в частности, исключая возможность обновления состояния компонентов самими собой. Такой подход делает поток данных предсказуемым и позволяет легче проследить причины возможных ошибок в программном обеспечении.

В минимальном варианте Flux-архитектура может содержать три слоя, взаимодействующие по порядку:

- Действия (англ. actions) — выражение событий (часто для действий используются просто имена — строки, содержащие некоторый «глагол»). Диспетчеры передают действия нижележащим компонентам (хранилищам) по одному. Новое действие не передаётся пока предыдущее полностью не обработано компонентами. Действия из-за работы источника действия, например, пользователя, поступают асинхронно, но их диспетчеризация явлется синхронным процессом. Кроме имени (англ. name), действия могут иметь полезную нагрузку (англ. payload), содержащую относящиеся к действию данные.
- Диспетчер/Диспатчер (англ. dispatcher) предназначен для передачи действий хранилищам. В упрощённом варианте диспетчер может вообще не выделяться, как единственный на всё приложение. В диспетчере хранилища регистрируют свои функции обратного вызова (callback) и зависимости между хранилищами.
- Хранилище (англ. store) является местом, где сосредоточено состояние (англ. state) приложения. Остальные компоненты, согласно Flux, не имеют значимого (с точки зрения архитектуры) состояния. Изменение состояния хранилища происходит строго на основе данных действия и старого состояния хранилища при помощи чистых функций.
- Представление (англ. view) — компонент, обычно отвечающий за выдачу информации пользователю. Во Flux-архитектуре, которая может технически не касаться внутреннего устройства представлений вообще, это — конечная точка потоков данных. Для информационной архитектуры важно только, что данные попадают в систему (то есть, обратно в хранилища) только через действия.
##
</details>

<details>
<summary>6. Зачем нужен Redux Toolkit если есть Redux?</summary>

##
Он был разработан для решения трех главных проблем:

- Слишком сложная настройка хранилища (store)
- Для того, чтобы заставить Redux делать что-то полезное, приходится использовать дополнительные пакеты
- Слишком много шаблонного кода (boilerplate)
##
</details>

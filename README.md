# Вопросы на собесах Frontend (CSS, JS, TS, React and Next.js)

# CSS
<details>
<summary>1. В чем разница - display, visibility, opacity?</summary>

##
- display

Многоцелевое свойство, которое определяет, как элемент должен быть показан в документе.

- visibility

Предназначен для отображения или скрытия элемента, включая рамку вокруг него и фон. При скрытии элемента, хотя он и становится не виден, место, которое элемент занимает, остается за ним

- opacity

Определяет уровень прозрачности элемента веб-страницы. При частичной или полной прозрачности через элемент проступает фоновый рисунок или другие элементы, расположенные ниже полупрозрачного объекта.
##
</details>

<details>
<summary>2. Box-sizing и Border-box - что за свойства?</summary>

##
- box-sizing

Применяется для изменения алгоритма расчета ширины и высоты элемента.
```css
box-sizing: border-box;
```
На ширину блока не влияет padding и border.
##
</details>

<details>
<summary>3. position: sticky - как работает?</summary>

##
```css
position: fixed;
```
Элемент удаляется из обычного потока документа и становится выше всех других элементов обычного потока. Элемент будет всегда находится в зоне просмотра (viewport) браузера и позиционироваться относительно зоны просмотра. Положение элемента можно изменять используя свойства top, right, bottom, left и z-index.

```css
position: sticky;
```
Элемент остается в обычном потоке документа, а затем "прилипает" к ближайшему родителю с прокруткой и скроллится вместе с ним. В народе это называют "липким" элементом, который прилипает к верху экрана при прокрутке, когда прокрутка достигает этого элемента.
##
</details>

<details>
<summary>4. Какие существуют псевдоэлементы и псевдоклассы?</summary>

##
- псевдоэлементы

1. :after, :before

создает псевдоэлемент, который является последним (:after) или первым (:before) потомком элемента. Обычно используется для создания декоративных элементов для выбранного элемента.

2. :placeholder 

Псевдоэлемент позволяет стилизовать текст, который был вставлен используя атрибут placeholder для элементов форм, таких как ``input`` и ``textarea``

- псевдоклассы

1. :first-child, :last-child

Псевдокласс позволяет стилизовать первый или последний дочерний элемент какого-либо блока.

2. :focus

Псевдокласс применяется когда человек взаимодействует с элементом форм (``form``) такими как ``input, textarea, select, button`` и ссылки. Активируется при клике мышью пользователем по элементу. При фокусе на элементе появляется обводка (``outline``) по умолчанию

3. :hover

Псевдокласс срабатывает в момент наведения курсора мыши на элемент.

4. :visited

Псевдокласс позволяет стилизовать посещенные ссылки.

5. :active

Псевдокласс срабатывает в момент нажатия левой кнопки мыши на элемент.
##
</details>

<details>
<summary>5. Tag picture - как применять?</summary>

##
Контейнер в котором должен быть один тег `img` и элементы `source` с разными источниками и условиями отображения. Браузер подберет подходящее изображение из элемента `source` или использует источник в теге `img`, если подходящего источника не было найдено.

```css
<picture>
    <source media="(max-width: 650px)" srcset="https://htmlbase.ru/storage/app/media/travel-mobile.jpg"></source>
    <img src="https://htmlbase.ru/storage/app/media/travel.jpg" alt=""></img>
</picture>
```
##
</details>

<details>
<summary>6. Что такое Pixel Perfect?</summary>

##
Pixel Perfect — это подход в вёрстке, когда итоговый результат максимально точно, пиксель в пиксель, совпадает с дизайнерским макетом. Для этого макет сайта сохраняется как обычная картинка, после чего эта картинка накладывается поверх свёрстанного сайта при помощи специальных инструментов, например, браузерных расширений. После наложения становится очевидной разница, если она есть, между тем, как нарисовал дизайнер, и тем, что получилось в итоге.
##
</details>

---

# JavaScript
<details>
<summary>1. Что такое замыкание?</summary>

##
При создании функции и использования внутри нее переменных, эти переменные доступны только локально внутри функции. Снаружи мы не можем получить к ним доступ. На хранение таких переменных в том числе и аргументов выделяется определенная память и когда функция заканчивает свое выполнение это память очищается. Таким образом эти переменные больше не где не существуют.

Но вот если внутри одной функции создать вторую то вложенная функция получит доступ к переменным которые были объявлены во внешней функции этот механизм
и называется замыканием т е вложенная функция замыкает на себе переменные и аргументы внешней функции.

Таким образом при отработке внешней функции возвращается внутренняя которая замыкается на значения внешней и не дает памяти очистится 

Где используется: если нужно создать приватные переменные внутри другой функции. Конфиденциальность данных / эмуляция скрытых методов при помощи замыканий. Обычно используется в модульном паттерне.

Замыкание технически включает три компонента:

- внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные - лексическое окружение
- переменные (лексическое окружение), которые определены во внешней функции
- вложенная функция, которая использует эти переменные
```js
function outer(){         // внешняя функция
    let x = 5;            // некоторая переменная          
    function inner(){     // вложенная функция
        console.log(x++); // действия с переменной x
    };
    return inner;
}
let fn = outer();   // fn = inner, так как функция outer возвращает функцию inner, 
// переменная fn будет хранить ссылку на функцию inner. 
// При этом эта функция запомнила свое окружение - то есть внешнюю переменную x.
// вызываем внутреннюю функцию inner
fn();   // 5
fn();   // 6
fn();   // 7
let newFn = outer();  // здесь также в переменной newFn хранится ссылка
// на функцию inner и содержит уже новое значение, начиная со значения 5
newFn() // 5
newFn() // 6
```
Замыкания удобны тем, что каждый новый вызов создаёт отдельную область, в которой значения абсолютно независимы друг от друга.
##
</details>

<details>
<summary>2. Что такое цикл событий (event loop) и как он работает?</summary>

##
Так как движок Node.js одопоточный т.е выполнение каких либо задач выполняется по очереди один за другим.

При вызове какой-то функции она попадает в так называемый стек вызовов.В стеке вызовов хранятся функции, до которых дошёл интерпретатор, и которые надо выполнить. После выполнения всего блока (разных функции к примеру) стек станет пустым. В синхронном коде в стеке хранится вся цепочка вызовов.

Управление тем, как должны вызываться асинхронные операции, берёт на себя цикл событий (Event loop).

Цикл событий отвечает за выполнение кода, сбор и обработку событий и выполнение подзадач из очереди.
```
Стек вызовов => Web API => Очередь задач
Очередь задач => Стек вызовов
```
- **Стек вызовов** - "первым пришел, последним вышел" или "последним пришел, первым вышел", что то же самое.
- **Очередь задач** - "первым пришел, первым ушел".
##
</details>

<details>
<summary>3. Контекст this</summary>

## 
this - это специальная переменная, которая ссылается, на тот объект, в котором она на данный момент находится.

```js
let obj = {
   model: "toyota",
   year: 2017,
   show: function() {
   console.log(this.model) // obj.model
   }
 };
obj.show()
```
##
</details>

<details>
<summary>4. В чем разница между null и undefined?</summary>

##
Оба варианта означают пустое значение. Если мы инициализируем
переменную, но не присваиваем ей значение, туда помещается специальный
«маркер», который отображается при выводе на экран как undefined. Null
присваиваем самостоятельно.

Null - Это просто специальное значение, которое представляет собой «ничего»,
«пусто» или «значение неизвестно». Если необходимо очистить значение
переменной, мы делаем q = null.
undefined означает, что «значение не было присвоено».
##
</details>

<details>
<summary>5. Стрелочные функции и их отличие от функций, объявленных через function</summary>

## 
- Стрелочные функции не имеют argumemts.
- Синтаксис
- У стрелочных функций нет своего this. Если идет обращение к this, то он
берется снаружи.
- Не могут быть функциями – конструкторами. Т.е не могут вызываться с
помощью new
- Cтрелочную функцию можно написать в одну строку без объявления слова return
##
</details>

<details>
<summary>6. Что такое set и map?</summary>

##
Map – это коллекция, структура данных, работающая по принципу
ключ/значение, как и Object. Но основное отличие от объекта в том, что Map
позволяет использовать ключи любого типа.

Объект Set – это особый вид коллекции: «множество» значений (без ключей),
своего рода массив, где каждое значение может появляться только один раз.
##
</details>

<details>
<summary>7. Какие значения являются falsy (ложными) значениями?</summary>

##
Falsy значение – значение, которое при приведении к логическому типу
возвращает false.

```js
console.log(false)
console.log(0)
console.log('')
console.log(undefined)
console.log(null)
console.log(NaN)
console.log(BigInt(0))
```
##
</details>

<details>
<summary>8. Что такое Promise?</summary>

##
Промис (Promise) — специальный объект JavaScript, который используется для написания и обработки асинхронного кода.

Асинхронные функции возвращают объект Promise в качестве значения. Внутри промиса работает асинхронная операция, которая управляет его состоянием.\
Промисы были придуманы для решения проблемы так называемого «ада функций обратного вызова».

Промис может находиться в одном из трёх состояний:

- pending — стартовое состояние, операция стартовала;
- fulfilled — получен результат;
- rejected — ошибка.

Поменять состояние можно только один раз: перейти из `pending` либо в `fulfilled`, либо в `rejected`:

У промиса есть методы `then()` и `catch()` и `finally`, которые позволяют выполнять код при изменении его состояния.

Метод `then()` после `catch()` будет вызываться, даже если не произошло ошибок и сам метод `catch()` не выполнялся.

Если в цепочке несколько `catch()`, то каждый ловит ошибки от `then()`, находящихся выше.

Метод `finally` выполняется в конце цепочки промисов вне зависимости произошла ошибка или выполнение промиса прошло успешно.
##
</details>

<details>
<summary>9. Что такое async/await?</summary>

##
Async/await — относительно новый способ написания асинхронного (неблокирующего) кода в JS. Им оборачивают промис. Он делает код более читаемым и чистым, чем промисы и функции обратного вызова.\
Функция, обозначенная как async всегда вернет Promise.

Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока
промис справа от await не выполнится. После чего оно вернёт его результат, и
выполнение кода продолжится. await нельзя использовать в обычных функциях
##
</details>

<details>
<summary>10. Для чего нужен оператор spread?</summary>

##
Спред-синтаксис (spread) ... позволяет передавать итерируемые коллекции (например, массивы или строки) как список аргументов функции или добавлять содержащиеся в них элементы в новый массив.

Спред применятся и для объектов, чтобы копировать пары ключ-значение из одного объекта в другой.

- При вызове функции использовать значения из массива как аргументы:
```js
function multiplyThreeNumbers(a, b, c) {
  return a * b * c
}

const nums = [1, 2, 3]

console.log(multiplyThreeNumbers(...nums)) // 6
```

- В массиве скопировать элементы из другого массива в новый:

```js
const donor = ['это', 'старые', 'значения']
const newArray = [...donor, 1, true, 'мама']

console.log(newArray) // ['это', 'старые', 'значения', 1, true, 'мама']
```

- У объекта скопировать свойства из другого объекта в новый:

```js
const persona = { name: 'Иван', lastName: 'Объектов'}
const userData = { ...persona, username: 'killer3000' }

console.log(userData)
// {
//    name: 'Иван',
//    lastName: 'Объектов',
//    username: 'killer3000'
// }
```
Если в массиве будет больше элементов, чем параметров функции, то будут использованы только те элементы, которые идут первыми по порядку:

```js
function multiplyThreeNumbers(a, b, c) {
  return a * b * c
}

const nums = [1, 2, 3, 5, 6]

console.log(multiplyThreeNumbers(...nums)) // 6
```
##
</details>

<details>
<summary>11. Поверхностное и глубокое копирование</summary>

##
При копировании объектов или массивов JavaScript копирует данные только на один уровень вглубь. Этот тип копирования называется поверхностным (shallow).

Если необходимо полностью скопировать сложную структуру данных, например, массив с объектами, то нужно делать глубокое (deep) или полное копирование данных. JavaScript не содержит функций для глубокого копирования, лучший вариант сделать глубокую копию — сериализовать структуру в JSON и тут же распарсить.

- Поверхностное копирование
---
```
const copy = {…obj}
```
- Глубокое копирование
---
1. Воспользоваться костыльным, медленным способом:
```js
const copy = JSON.parse(JSON.stringify(obj))
```
или методом `structuredClone()`
Такие способы подойдет для объекта без прототипа и без функций.

2. Реализовать рекурсивную функцию копирования полей.
3. Воспользоваться библиотекой lodash, функцией deep clone
##
</details>

<details>
<summary>12. Что такое деструктуризация?</summary>

##
В JavaScript есть две чаще всего используемые структуры данных – это Object
и Array. Деструктурирующее присваивание – это специальный синтаксис, который
позволяет нам «распаковать» массивы или объекты в кучу переменных, так как
иногда они более удобны.
##
</details>

<details>
<summary>13. Что такое DOM дерево?</summary>

##
DOM (Document Object Model) — это специальная древовидная структура, которая позволяет управлять HTML-разметкой из JavaScript-кода. Управление обычно состоит из добавления и удаления элементов, изменения их стилей и содержимого.

Браузер создаёт DOM при загрузке страницы, складывает его в переменную document и сообщает, что DOM создан, с помощью события DOMContentLoaded. С переменной document начинается любая работа с HTML-разметкой в JavaScript.
##
</details>

<details>
<summary>14. Всплытие и погружение событий в DOM дереве</summary>

##
- Всплытие.

Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так
далее, вверх по цепочке предков.

- Погружение

Стандарт DOM Events описывает 3 фазы прохода события:
1. Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
2. Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
3. Фаза всплытия (bubbling stage) – событие начинает всплывать.
##
</details>

<details>
<summary>15. Всплытие в JS</summary>

##
Hoisting (всплытие) представляет процесс доступа к переменным до их определения.

- `var`-переменные, которые попадают под всплытие, по умолчанию получают значение undefined.

- Это также касается и функции котрые обьявлются через `Function Declaration`

```js
display();
 
function display(){
    console.log("Hello Hoisting");
}
```
Здесь функция `display` благополучно отработает, несмотря на то, что она определена после вызова.

Но если мы используем `Function Expression` и вызовем ее до объявления то будет ошибка.
```js
display();

var display = function (){
    console.log("Hello Hoisting");
}
```
При первом проходе компилятор также получит переменную `display` и присвоет ей значение `undefined`. При втором проходе, когда надо будет вызывать функцию, на которую будет ссылаться эта переменная, компилятор увидит, что вызывать то нечего: переменная `display` пока еще равна `undefined`. И будет выброшена ошибка.

- Процесс всплытие для `let` и `const` будет отличаться: в отличие от `var`-переменных `const` и `let` при всплытие **не присваивается начальное значение**.

```js
console.log(foo);   // ReferenceError: Cannot access 'foo' before initialization
let foo = "Tom";    // тоже самое и с 'const'
console.log(foo);   // не будет выполняться
```
##
</details>

<details>
<summary>16. Для чего нужны полифилы?</summary>

##
«Полифил» – это библиотека, которая добавляет в старые
браузеры поддержку возможностей, которые в современных браузерах являются
встроенными.
##
</details>

<details>
<summary>17. Расскажите о функциях - конструкторах</summary>

## 
Функции-конструкторы являются обычными функциями. Но есть два
соглашения:
1. Имя функции-конструктора должно начинаться с большой буквы.
2. Функция-конструктор должна вызываться при помощи оператора "new".
```js
function User() {
  this.name = 'Alex'
}

const firstUser = new User()
firstUser.name === 'Alex' // true
```
Когда функция вызывается как new User(...), происходит следующее:
1. Создаётся новый пустой объект, и он присваивается this.
2. Выполняется код функции. Обычно он модифицирует this, добавляет туда
новые свойства.
3. Возвращается значение this
##
</details>

<details>
<summary>18. Микро и макро таски в JavaScript</summary>

##
- MicroTask - Promises ... выполняються раньше 
- MacroTask - SetTimeout ... выполняються позже
##
</details>

<details>
<summary>19. Что представляет из себя чистая функция?</summary>

##
Функция должна удовлетворять двум условиям, чтобы считаться «чистой»
- Каждый раз функция возвращает одинаковый результат, когда
вызывается с тем же набором аргументов.
- Нет побочных эффектов: HTTP-вызовы внутри функции, вывод на экран ( что то изменяет или внедряет в DOM дерево или происходит манипуляция с браузерными событиями по типу `click`).
##
</details>

<details>
<summary>20. Что представляет из себя функция высшего порядка?</summary>

##
Функция высшего порядка — это функция, которая может принимать другую
функцию в качестве аргумента или возвращать другую функцию в качестве
результата.
##
</details>

<details>
<summary>21. Ссылочные типы данных в js?</summary>

##
Все типы данных JavaScript можно разделить на примитивные и ссылочные.

- Объекты как ссылочные типы

Одно из фундаментальных отличий объектов от примитивов заключается в том, что объекты хранятся и копируются «по ссылке», тогда как примитивные значения: строки, числа, логические значения и т.д. – всегда копируются «как целое значение».

Переменная, которой присвоен объект, хранит не сам объект, а его «адрес в памяти» – другими словами, «ссылку» на него.

При копировании переменной объекта копируется ссылка, но сам объект не дублируется.

```js
let x = [10, 9, 8];
let y = x;
x[0] = 2;

console.log(y[0]); // 2
```

- Передача объектов функциям

Когда следует уделять особое внимание ссылочным типам, возникает при передаче их в виде аргументов функциям. Ввиду того что ссылочные типы содержат ссылки на соответствующие реальные данные, аргументы функции получают копию ссылки на данные и могут, таким образом, менять оригинальные данные.

- Сравнение объектов

При использовании операции проверки равенства (==) интерпретатор сравнивает значения соответствующих переменных. Для примитивных типов это означает сравнение фактических данных.

В случае ссылочных типов переменные содержат ссылки на данные, а не сами данные. Поэтому при использовании операции проверки равенства происходит сравнение ссылок, а не объектов, на которые эти ссылки указывают. Другими словами, операция == обеспечивает проверку не того, что две переменные ссылаются на эквивалентные объекты, а того, что переменные ссылаются на один и тот же объект.

```js
let str1 = new String("abc");
let str2 = new String("abc");

console.log(strl == str2); // false
```
##
</details>

<details>
<summary>22. Cookie, localStorage и sessionStorage?</summary>

##
Существует несколько подходов к хранению данных в браузере:

1. LocalStorage, SessionStorage - это интерфейс взаимодействия с хранилищем.

**SessionStorage** похож на краткосрочные Cookie, потому что данные в этом хранилище хранятся только во время жизни текущей сессии.

**LocalStorage**, в теории, является бессрочным хранилищем данных.

- Позволяют хранить пары ключ/значение в браузере.
- Максимальный объем хранимых данных — 5 Мб.
- Что в них важно – данные, которые в них записаны, сохраняются после
обновления страницы.

Оба хранилища в качестве ключей и значений могут использовать только
строки, поэтому объекты не забываем преобразовывать с помощью JSON.stringify.

2. **Cookie** – это небольшие строки данных, которые хранятся непосредственно в браузере. Данные, хранящиеся в куках, также передаются на сервер в виде HTTP-заголовка и могут быть им изменены. 

У хранения данных в **Cookie** есть много ограничений.

- они передаются при каждом запросе к серверу.
- их размер ограничен 4096 байтами. 
- срок хранения данных по умолчанию ограничен длинной сессии.

Куки обычно устанавливаются веб-сервером при помощи заголовка Set-Cookie. 
Мы также можем получить доступ к куки непосредственно из браузера, используя свойство document.cookie.

Один из наиболее частых случаев использования куки – это **аутентификация**:

- При входе на сайт сервер отсылает в ответ HTTP-заголовок Set-Cookie для того, чтобы установить куки со специальным уникальным идентификатором сессии («session identifier»).
- Во время следующего запроса к этому же домену браузер посылает на сервер HTTP-заголовок Cookie.
- Таким образом, сервер понимает, кто сделал запрос.
##
</details>

<details>
<summary>23. Что такое Intersection Observer API?</summary>

##
Intersection Observer API (IOA) позволяет приложению асинхронно наблюдать за пересечением элемента (target) с его родителем (root) или областью просмотра (viewport). Другими словами, этот API обеспечивает вызов определенной функции каждый раз при пересечении целевого элемента с root или viewport.

Примеры использования:

- «ленивая» или отложенная загрузка изображений
- бесконечная прокрутка страницы
- получение информации о видимости рекламы для целей расчета стоимости показов
- запуск процесса или анимации, находящихся в поле зрения пользователя

Для начала работы с IOA необходимо с помощью конструктора создать объект-наблюдатель с двумя параметрами — функцией обратного вызова и настройками

```js
// настройки
let options = {
    root: document.querySelector('.scroll-list'),
    rootMargin: '5px',
    threshold: 0.5
}

// функция обратного вызова
let callback = function(entries, observer){
    ...
}

// наблюдатель
let observer = new IntersectionObserver(callback, options)
```

Настройки:

- root — элемент, который выступает в роли области просмотра для target (предок целевого элемента или null для viewport)
- rootMargin — отступы вокруг root (margin в CSS, по умолчанию все отступы равны 0)
- threshold — число или массив чисел, указывающий допустимый процент пересечения target и root

Далее создается целевой элемент, за которым наблюдает observer:

```js
let target = document.querySelector('.list-item')
observer.observe(target)
```

Вызов callback возвращает объект, содержащий записи об изменениях, произошедших с целевым элементом:

```js
let callback = (entries, observer) => {
    entries.forEach(entry => {
        // entry (запись) - изменение
        //   entry.boundingClientRect
        //   entry.intersectionRatio
        //   entry.intersectionRect
        //   entry.isIntersecting
        //   entry.rootBounds
        //   entry.target
        //   entry.time
    })
}
```
##
</details>

<details>
<summary>24. Архитектура и паттерны проектирования в JavaScript? </summary>

##
**Архитектура**

- Backend \
**MVC** - (model-view-controler)
- Frontend \
**PMCU** - (pages-models-components-ul)
- Глобальное хранилище состояний \
**Flux** - Redux\MobX

**Паттерны проектирования `React`**

1. Presentational and Container Component Pattern

- **Компоненты представления**: это компоненты, отвечающие за внешний вид пользовательского интерфейса. Они не имеют никаких зависимостей ни с одной частью приложения и используются для отображения данных. Примером является список.

2. Provider Pattern

- Этот паттерн позволяет нам хранить данные в центральном месте, например, `React Context` и `Redux store`. `Provider/Store` может передать эти данные любому компоненту, которому они нужны, напрямую, без проп-дриллинга.

3. Compound Components Pattern

- Составные компоненты (Compound Components)— это компоненты, которые имеют общее состояние и работают вместе для достижения общей цели. Примером могут служить `HTML-элементы select и option`. В сочетании вместе они создают выпадающее меню, но сами по себе они мало что делают. Паттерн `Compound Components` используется в популярных библиотеках пользовательского интерфейса `React`, например: `Ant Design` и `Material UI`.
##
</details>

<details>
<summary>25. Что такое инкремент/декремент? </summary>

##
Одной из наиболее частых числовых операций является увеличение или уменьшение на единицу.

Для этого существуют даже специальные операторы:

- **Инкремент** ++ увеличивает переменную на 1:
```js
let counter = 2;
counter++;        // работает как counter = counter + 1, просто запись короче
console.log( counter ); // 3
```
- **Декремент** -- уменьшает переменную на 1:
```js
let counter = 2;
counter--;        // работает как counter = counter - 1, просто запись короче
console.log( counter ); // 1
```
- Если результат оператора не используется, а нужно только увеличить/уменьшить переменную, тогда без разницы, какую форму использовать:
```js
let counter = 0;
counter++;
++counter;
console.log( counter ); // 2, обе строки сделали одно и то же
```
- Если хочется тут же использовать результат, то нужна префиксная форма:
```js
let counter = 0;
console.log( ++counter ); // 1
```
- Если нужно увеличить и при этом получить значение переменной до увеличения – нужна постфиксная форма:
```js
let counter = 0;
console.log( counter++ ); // 0
```
##
</details>

<details>
<summary>26. В чем разница между оператором «in» и методом hasOwnProperty? </summary>

##
Отличие состоит в том, что оператор «in» проверяет наличие свойства не только в самом объекте, но и в его прототипах, а метод hasOwnProperty — только в объекте.
##
</details>

<details>
<summary>27. Что такое callback-функция?</summary>

##
коллбэк — это функция, которая должна быть выполнена после того, как другая функция завершила выполнение (отсюда и название: callback — функция обратного вызова). Любая функция, которая передается как аргумент, называется callback-функцией.
##
</details>

<details>
<summary>28. Что такое генераторы в javascript и как они работают?</summary>

##
Генераторы могут порождать (yield) множество значений одно за другим, по
мере необходимости. Генераторы отлично работают с перебираемыми объектами и
позволяют легко создавать потоки данных.

Для объявления генератора используется специальная синтаксическая
конструкция: function*, которая называется «функция-генератор»

```js
function* generateFuncion () {
   yield 1;
   yield 2;
   return 3;
}
```
Основным методом генератора является `next()`. При вызове он запускает
выполнение кода до ближайшей инструкции `yield` <значение> (значение может
отсутствовать, в этом случае оно предполагается равным `undefined`). По достижении
`yield` выполнение функции приостанавливается, а соответствующее значение –
возвращается во внешний код

```js
let generator = generateFuncion()
let one = generator.next()
```
##
</details>

<details>
<summary>29. Чем отличается PUT от PATCH и какие существуют методы запроса?</summary>

##
- `GET` запрашивает представление указанного ресурса. Такие запросы только для получения данных.
- `HEAD` - служит для проверки существования ресурса, он полностью аналогичен `GET`, но без возврата тела ответа.
- `POST` предназначен для отправки данных на сервер. Тип тела запроса указывается в заголовке `Content-Type`.
- `DELETE` запроса удаляет указанный ресурс.
- `PUT`, выбирается из базы сущность и обновляются её поля, при чём все сразу.
- `PATCH`, тоже самое, только обновляются не все поля, а выборочно.
- `OPTIONS` возвращает параметры в заголовке. Список параметров зависит о ресурса и/или сервера. Обычно это заголовок `Allow`, который описывает какие методы доступны для ресурса.
##
</details>

<details>
<summary>30. Что такое HTTP и HTTPS?</summary>

##
HTTP — это протокол передачи данных (гипертекстовой разметки) между браузером и сервером: страниц, файлов, видеозаписей. HTTPS — это тот же HTTP, но с добавленными методами шифрования данных и проверки безопасности. Встретить сейчас ресурс на HTTP довольно сложно — им не доверяют ни пользователи, ни браузеры, ни поисковики.

Протоколы TLS (Transport Layer Security) — криптографические. Это значит, что они позволяют шифровать данные, в нашем случае те, что передаются между браузером и сервером. Расшифровать эти данные могут только сервер и браузер, для всех остальных это будет набор нечитаемых символов.
##
</details>

<details>
<summary>31. Из чего состоит тело запроса fetch?</summary>

##
Функция fetch() принимает два параметра:

- url — адрес, по которому нужно сделать запрос;
```js
fetch('http://jsonplaceholder.typicode.com/posts')
```
- options (необязательный) — объект конфигурации, в котором можно настроить метод запроса, тело запроса, заголовки и многое другое.
```js
fetch('https://jsonplaceholder.typicode.com/posts', {
  method: 'POST', // Здесь так же могут быть GET, PUT, DELETE
  body: JSON.stringify(newPost), // Тело запроса в JSON-формате
  headers: {
    // Добавляем необходимые заголовки
    'Content-type': 'application/json; charset=UTF-8',
  },
```
По умолчанию fetch() запросы не включают в себя cookies и потому авторизованные запросы на сервере могут не пройти. Для этого необходимо добавить в настройку поле credentials:
```js
fetch('https://somesite.com/admin', {
  method: 'GET',
  // или 'same-origin' если можно делать такие запросы только в пределах этого домена
  credentials: 'include',
})
```
##
</details>

<details>
<summary>32. Расскажите, как работает прототипное наследование</summary>

##
Все объекты в JavaScript имеют свойство `__proto__`, которое является ссылкой на другой объект. Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на одном из прототипов или до тех пор, пока он не достигнет конца цепочки прототипов.
##
</details>

<details>
<summary>33. В чем разница между методами preventDefault и stopPropagation?</summary>

##
- Метод `preventDefault` объекта Event, отключает стандартную обработку события браузером. 
- Метод `stopPropagation` объекта Event, отключает распространение события, т.е. запуск родительских по отношению к элементу, в котором возникло событие, обработчиков.

Например, "дефолтная" обработка события `submit` элемента `form` предполагает отправку данных формы и перезагрузку страницы.
```js
<form id="formEl">
  <input type="text" id="inputEl" />
  <button>Отправить</button>
</form>
```
```js
formEl.onsubmit = (e) => {
  e.preventDefault()
  alert(inputEl.value || 'hello world')
}
```
Пример всплытия в дереве DOM и с помощью метода `stopPropagation` отключение этого всплытия.
```js
<body>
  <div id="blueRect">
    <div id="redRect"></div>
  </div>
</body>
```
```js
const redRect = document.getElementById("redRect");
redRect.addEventListener("click", function(){
    console.log("Событие на redRect");
});
 
const blueRect = document.getElementById("blueRect");
blueRect.addEventListener("click", function(){
    console.log("Событие на blueRect");
});
 
document.body.addEventListener("click", function(){
    console.log("Событие на body");
});
```
Если мы нажмем на вложенный `div`, то событие пойдет к родительскому элементу `div` и далее к элементу `body`:

Вывод в консоли будет следующий:
```js
`Событие на redRect`
`Событие на blueRect`
`Событие на body`
```
Чтобы остановить распространение событие, мы можем прибегнуть к методу `stopPropagation()` объекта Event.
```js
const redRect = document.getElementById("redRect");
redRect.addEventListener("click", function(e){
    console.log("Событие на redRect");
    e.stopPropagation();
});
```
И в результате нажатия событие будет обработано только обработчиком для `redRect`.
```js
`Событие на redRect`
```
##
</details>

<details>
<summary>34. Что такое CORS?</summary>

##
CORS - это механизм, который позволяет выполняемым скриптам в браузере взаимодействовать с ресурсами, имеющий **разный origin**. Под **разным origin** подразумевается запросы, который имеют разный URL (ссылку) по сравнению с URL, где выполняется JavaScript.

Примеры:
- Разный домен(js.com)
- Разный протокол(http и https)
- Разный порт(js.com:3000 и js.com:3001)

На стороне Back-end можно конфигурировать такие заголовки (`headers`) которые разрешат получать доступ с этого ресурса:
```js
app.use(function (req, res, next) {
    res.setHeader('Access-Control-Allow-Origin', 'http://localhost:3000' || '*'); 
    //  должен содержать разрешённый источник или все источники.
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, PATCH, DELETE'); 
    // должен содержать разрешённые методы.
    res.setHeader('Access-Control-Allow-Headers', 'X-Requested-With,content-type'); 
    // должен содержать список разрешённых заголовков.
    res.setHeader('Access-Control-Allow-Credentials', true); 
    // Если сервер согласен принять запрос с авторизационными данными, он должен добавить заголовок
    next();
}); 
```
Типы запросов CORS:

1. Простые

- Считаются методы `GET`, `POST` или `HEAD`
- При использовании заголовка Content-Type должны быть такие значения `application/x-www-form-urlencoded`, `multipart/form-data` или `text/plain`.

2. Все отсальные 

Если запрос не является **простым**, то браузер автоматически пошлет запрос с методом `OPTIONS`.

Цель такого запроса разузнать возможности CORS сервера:

Если сервер вернет `headers` (заголовки), кототрые разрешат доступ к ресурсам, то браузер пошлет второй запрос.
##
</details>

<details>
<summary>35. Переменные const, let и var их отличия</summary>

##
Переменные — это именованные контейнеры для хранения данных.

1. `let`, `const` 

Используя ключевое слово `let`, можно объявить переменную без присвоения ей начального значения. В таком случае она будет равна `undefined`
```js
let a
console.log(a) // undefined

a = 5
console.log(a) // 5
```
А вот при помощи `const` нельзя объявлять переменные без значения это вызовет ошибку.

Оба типа переменных имеют блочную область видимости и не становятся частью глобального объекта (`window` в браузере, `global` в Node.js). Блочная область видимости не даёт получить значение переменной вне блока, где она была объявлена.
```js
if (true) {
  let a = 5
  const b = 10

  console.log(a)   // 5
  console.log(b)   // 10
}

console.log(a) // ReferenceError: a is not defined
console.log(b) // ReferenceError: b is not defined
```

Значение в переменной, созданной через `let`, можно изменять
```js
let a = 5
console.log(5) // 5

a = 10
console.log(a) // 10
```
А вот значение `const` изменить нельзя, будь то примитивное значение или ссылка на объект.
```js
const obj = {
  a: 5,
}
obj = {
  a: 10,
} // TypeError: Assignment to constant variable
```
Однако объект, хранящийся в `const`, можно мутировать. Объекты хранятся по ссылке, и изменение объекта не приводит к изменению ссылки на него.
```js
const obj = {
  a: 5,
}

obj.a = 10
console.log(obj) // { a: 10 }
```
2. `var`

Переменные `var` можно объявлять без присвоения им значения, в таком случае они будут равны `undefined`

Переменные, объявленные через `var`, имеют функциональную область видимости. Они доступны только в пределах текущей функции или глобального объекта, если функции нет
```js
if (true) {
  var a = 5
}
function foo() {
  var b = 10
}

console.log(a) // 5
console.log(b) // ReferenceError: b is not defined
```
Смена значения в `var`

- обратиться к имени переменной и присвоить новое значение
```js
var a = 5
console.log(a) // 5

a = 10
console.log(a) // 10
```
- обратиться к имени переменной вместе с ключевым словом `var`
```js
var a = 5
console.log(a) // 5

var a = 10
console.log(a) // 10
```

Использование `var` оправданно, если нужно писать код для старых браузеров времён `IE 11` или `Opera mini`. Или нужно работать с библиотеками которые напиманы на `var` и читать доку где примеры также написаны с использованием `var`. Во всех остальных случаях лучше использовать `let` и `const`, так как они не позволят допустить ошибки, приводящие к неправильным значениям в переменных или изменениям глобальных переменных.
##
</details>

<details>
<summary>36. Какие существуют области видимости?</summary>

##
**Глобальная область видимости** - все переменные и константы, которые объявлены вне функций, вне модулей, являются глобальными.

**Блочная область видимости** - ограничена программным блоком, обозначенным при помощи `{` и `}`. Простейший пример такой области — это выражение внутри скобок.

**Функциональная область видимости** - это область видимости в пределах тела функции. Можно сказать, что она ограничена `{` и `}` функции.

**Лексической областью видимости** - особенный доступ к локальным переменным родительской функции.
```js
function outer() {
  const a = 42

  function inner() {
    console.log(a) // 42
  }
}
```
Такое поведение, когда переменные родительских областей становятся доступны в дочерних, называется наследованием областей видимости.
##
</details>

---

# React

<details>
<summary>1. Что такое Virtual Dom</summary>

##
VirtualDOM это копия DOM дерева и вместо того, чтобы взаимодействовать с
DOM напрямую, мы работаем с его легковесной копией. Мы можем вносить
изменения в копию, исходя из наших потребностей, а после этого React применяет
изменения к реальному DOM.

При этом происходит сравнение DOM-дерева с его виртуальной копией,
определяется разница и запускается перерисовка того, что было изменено.

Такой подход работает быстрее, потому как не включает в себя все
тяжеловесные части реального DOM.
##
</details>

<details>
<summary>2. Разница между контролируемыми и неконтролируемыми компонентами</summary>

##
В **контролируемом** компоненте данные формы обрабатываются компонентом React. 
Альтернативой являются **неконтролируемые** компоненты, где данные формы обрабатываются самим DOM.

В HTML элементы формы, **такие как input, textarea и select**, обычно
поддерживают собственное состояние и обновляют его в соответствии с
пользовательскими входными данными. В React изменяемое состояние обычно
хранится в свойстве state компонентов и обновляется только с помощью setState().

Мы можем объединить всё это вместе, сделав состояние React «единственным
источником данных (истины)». Затем компонент React, который отрисовывает
форму, также контролирует, что происходит в этой форме при последующем вводе
данных пользователем. Элемент поля ввода формы, значение которого
контролируется React подобным образом, называется **«контролируемым
компонентом»**.

Вместо того, чтобы писать обработчик события для каждого обновления
состояния, вы можете использовать **неуправляемый** компонент и читать значения
из DOM через ref

Неуправляемые компоненты опираются на DOM в качестве источника данных и могут быть удобны при интеграции React с кодом, не связанным с React. Количество кода может уменьшиться, правда, за счёт потери в его чистоте. Поэтому в обычных ситуациях мы рекомендуем использовать управляемые компоненты.
##
</details>

<details>
<summary>3. Что такое жизненный цикл компонента React и какие методы знаете?</summary>

##
Каждый компонент React проходит несколько стадий в процессе своей жизни: он создаётся, затем добавляется в DOM, получает пропсы, и, наконец, удаляется из дерева. Этот процесс называют жизненным циклом компонента (Component Lifecycle). React предоставляет набор методов, которые позволяют встроиться в этот процесс.

Существует четыре различных этапа жизненного цикла компонента React:
1. Инициализация: На этом этапе компонент React готовит установку
начального состояния и параметров по умолчанию.
2. Монтирование: Компонент React готов для монтирования в DOM
браузера. Этот этап охватывает методы жизненного цикла
componentWillMount и componentDidMount.
3. Обновление: На этом этапе компонент обновляется двумя способами,
отправляя новые свойства и обновляя состояние. Этот этап охватывает
методы жизненного цикла shouldComponentUpdate, componentWillUpdate
и componentDidUpdate.
4. Размонтирование: На этом последнем этапе компонент не нужен и
отключается из DOM браузера. Этот этап включает метод жизненного
цикла componentWillUnmount.
##
</details>

<details>
<summary>4. Зачем хуки добавили в React?</summary>

##
С помощью хуков мы можем извлечь логику состояния из компонента, чтобы её протестировать или повторно использовать. Хуки позволяют нам повторно использовать логику состояния, не затрагивая дерево компонентов. Благодаря этому, хуки легко использовать в разных компонентах и делиться ими с сообществом (К примеру кастомные хуки для валидации форм). 

Хуки позволяют использовать состояние и другие функции жизненного цикла при использовании функциональных компонентов вместо классов. Меньше кода и повышая читабельность компонентов.
##
</details>

<details>
<summary>5. Что такое React хуки и какие вы знаете?</summary>

##
Хук — это специальная функция, которая позволяет «подцепиться» к возможностям
React.
Основные React хуки:
- useState;
- useEffect;
- useContext;
- useRef;
- useMemo;
- useCallback;
##
</details>

<details>
<summary>6. useState особенности использования</summary>

##
Хук useState предоставляет функциональным компонентам доступ к состоянию React.

Он возвращает значение с состоянием и функцию для его обновления.
Во время первоначального рендеринга возвращаемое состояние (state)
совпадает со значением, переданным в качестве первого аргумента (initialState).

Функция setState используется для обновления состояния. Она принимает новое
значение состояния и ставит в очередь повторный рендер компонента. Функция
setState может принимать параметром, как и новое значение, так и функцию callback,
которая параметром принимает предыдущее значение.
##
</details>

<details>
<summary>7. useEffect особенности использования</summary>

##
С помощью хука useEffect можно управлять жизненным циклом компонета.

Функция принимает два параметра это callback и массив зависимостей.

Массив зависимостей в useEffect. если оставляем пустым, то useEffect срабатывает только при первом рендере компонента.

Если прописываем зависимости напр: `[val, val2]`, то функции внутри useEffect выполнятся когда произойдет изменение значения переменной val или val2.

Если не передать вообще то useEffect срабатывает на каждый рендер.

- Очистка ресурсов

Нередко в приложении возникает необходимость подисывается на различные ресурсы, а после окончания работы и отписываться от них. В этом случае мы можем использовать специальную форму хука useEffect():
```js
useEffect(() => {
  // код подписки на ресурс
  return () => {
    // код отписки от ресурса
  };
});
```
##
</details>

<details>
<summary>8. useLayoutEffect для чего нужен и когда использовать?</summary>

##
Хук `useLayoutEffect` по своим параметрам (сигнатуре) полностью идентичен хуку `useEffect`. Главное же отличие заключается в том, что `useLayoutEffect` вызывается синхронно, после всех изменений в DOM. Также сами разработчики React рекомендуют использовать `useLayoutEffect` только в случае острой необходимости, чтобы вдруг не возникло проблем с правильным рендерингом компонентов. **Хук `useLayoutEffect` можно использовать в случаях, когда необходимо произвести какие-то вычисления либо замеры в реальном DOM или провести синхронно мутацию (изменения)**.

Одно из применений заключается в устранении мигания во время рендера компонента.
##
</details>

<details>
<summary>9. useContext для чего нужен и когда использовать?</summary>

##
В типичном React-приложении данные передаются сверху вниз (от родителя к
дочернему компоненту) с помощью пропсов. Однако, подобный способ
использования может быть чересчур громоздким для некоторых типов пропсов
(например, выбранный язык, UI-тема), которые необходимо передавать во многие
компоненты в приложении. Контекст предоставляет способ делиться такими
данными между компонентами без необходимости явно передавать пропсы через
каждый уровень дерева.

Компонент, вызывающий useContext, всегда будет перерендериваться при
изменении значения контекста. Если повторный рендер компонента затратен, вы
можете оптимизировать его с помощью мемоизации.
##
</details>

<details>
<summary>10. useRef для чего нужен и когда использовать?</summary>

##
`useRef` возвращает изменяемый ref-объект, свойство `.current` которого инициализируется переданным аргументом (`initialValue`). Возвращённый объект будет сохраняться в течение всего времени жизни компонента и не будет изменяться от рендера к рендеру. Хук useRef не приводит к повторному перерендериванию компонента даже когда происходит изменение данных в нем.

Обычный случай использования — это явное обращение к DOM элементу (`Virtual Dom`). После инициализации данный хук вернет `ref-объект` со свойством `current`.

В качестве параметра функция `useRef()` принимает начальное значение хранимого объекта. А возвращаемое значение - ссылка-объект, из свойства current которого можно получить хранимое значение.

- Пример использования (инизиализация):
```js
const ref = useRef(null) // название переменной может быть любое
```

- В консоли будет выглядить следуйщим образом:
```js
console.log(ref) || console.log(ref.current);;

{current: null} || null
```

- Пример компонента:

```js
function Form() {
  const ref = useRef(null)  // инизиализация ref-объекта

  const focus = () => {
    ref.current.focus()  // форма с одним input и кнопкой по клику,
  }                      // на которую мы хотим устанавливать фокус на этот input.

  return (
    <>
      <input ref={ref} />  {/*обязательный атрибут иначе не получиться достучаться к этому DOM элементу*/}
      {/*console.log(ref) // {current: input}*/} 
      <button onClick={focus}>Focus</button>  {/*кнопка отрабатывающая фукцию focus*/}
    </>
  )
}
```

Это прекрасная возможность изменения DOM в `React`, но эта же возможность полностью противоречит концепции работы виртуального DOM. Из-за таких изменений не происходит умного сравнения в виртуальном DOM, что часто приводит к ошибкам.
##
</details>

<details>
<summary>11. useMemo для чего нужен и когда использовать?</summary>

##
useMemo используется для того, чтобы закешировать\замемоизировать результат вычислений.

Пример использования:
```js
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```
Предназначен для оптимизации проекта.
Этот хук возвращает не саму функцию, а результат её выполнения.
Таким образом, `useMemo` используется для сохранения результатов тяжёлых вычислений, например обработка массива. 

Передайте «создающую» функцию и массив зависимостей. `useMemo` будет
повторно вычислять мемоизированное значение только тогда, когда значение какой либо из зависимостей изменилось.

Первым параметром функция принимает callback, в котором проходят вычисления, а
вторым массив зависимостей, функция будет повторно проводить вычисления
только при изменении хотя бы одной из зависимостей
##
</details>

<details>
<summary>12. useCallback для чего нужен и когда использовать?</summary>

##
Хук useCallback вернёт мемоизированную версию колбэка, который
изменяется только, если изменяются значения одной из зависимостей. **Это полезно
при передаче колбэков оптимизированным дочерним компонентам, которые
полагаются на равенство ссылок для предотвращения ненужных рендеров.**

useCallback получает на функцию и массив аргументов, и возвращает одну и туже функцию, до тех пор, пока аргументы не изменились. **useCallback используется, когда важна постоянность ссылок на функцию.** 
##
</details>

<details>
<summary>13. Что такое JSX?</summary>

##
`JSX` — расширение синтаксиса `JavaScript`. Этот синтаксис выглядит как язык шаблонов, но наделён всеми языковыми возможностями `JavaScript`. 
`JSX` - это дополнение к синтаксису `JS`, который позволяет писать HTML в React компонентах. JSX — синтаксический сахар для функции React.createElement(component, props, ...children).

За правильный парсинг и дальнейшую обработку отвечает `babel`.

`React` можно использовать без `JSX`. Это особенно удобно, когда нет необходимости настраивать транспиляцию в процессе сборки.
##
</details>

<details>
<summary>14. Что такое props?</summary>

##
Props (обьект js) – данные, которые передаются в компонент из родительского. Props
доступны только для чтения и не могут быть изменены.
##
</details>

<details>
<summary>15. React.memo для чего нужен и когда использовать?</summary>

##
React.memo — это компонент высшего порядка.

Если ваш компонент всегда рендерит одно и то же при неменяющихся
пропсах, вы можете обернуть его в вызов React.memo для повышения
производительности в некоторых случаях, мемоизируя тем самым результат. Это
значит, что React будет использовать результат последнего рендера, избегая
повторного рендеринга.

React.memo затрагивает только изменения пропсов. Если функциональный
компонент обёрнут в React.memo и использует useState, useReducer или useContext,
он будет повторно рендериться при изменении состояния или контекста.
##
</details>

<details>
<summary>16. Как работает проп children?</summary>

##
Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar, которые представляют из себя как бы «коробку», в которую можно что-то положить. Для таких компонентов мы рекомендуем использовать специальный проп children, который передаст дочерние элементы сразу на вывод
##
</details>

<details>
<summary>17. Что такое порталы в React?</summary>

##
Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента.

```js
ReactDOM.createPortal(child, container)
```

Первый аргумент (child) — это любой React-компонент, который может быть отрендерен, такой как элемент, строка или фрагмент. Следующий аргумент (container) — это DOM-элемент.

Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки.
##
</details>

<details>
<summary>18. Для чего нужен атрибут key при рендере списков?</summary>

##
Ключи (keys) помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени.

Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи. Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ.
##
</details>

<details>
<summary>19. Почему react не реактивен?</summary>

##
React назван так потому, что реагирует на изменения состояния компонентов. Все же он делает это не реактивно, а, скорее, по графику.

Помните, что входными данными для render() являются свойства (props) и внутреннее состояние, которое может быть обновлено в любое время.

Когда для render меняются входные данные, меняется и результат ее выполнения.

React.js ведет запись жизненного цикла компонента. Когда React.js видит, что один рендер отличается от другого, он переводит разницу между своим виртуальным представлением в операции с DOM API, которые будут отрисованы в документе.

Не отслеживает в реальном времени изменения переменных.
##
</details>

<details>
<summary>20. Что такое компонент React?</summary>

##
- Компонент React – это класс, который наследуется от класса React.Component 
- Функция render возвращает HTML разметку, то что будет отрисовано в браузере. Класс-компонент без функции render существовать не может, это его интерфейс.
##
</details>

<details>
<summary>21. Что вызывает обновление компонента?</summary>

##
Обновление компонента вызывают изменение состояния и изменение пропсов. Изменение состояния не будет приводить к обновлениям, если новое значение состояния не изменилось. Если мутировать состояние напрямую это тоже не приведет к повторному рендеру. Когда родительский компонент рендерится, дочерние компоненты рекурсивно тоже будут ререндериться. React должен сделать рендер, чтобы определить эти различия, сравнить и определить нужна перерисовка или нет.
##
</details>

<details>
<summary>22. Что такое Pure Components (Чистые компоненты)?</summary>

##
Компонент является чистым, если он гарантированно возвращает один и тот же результат при одинаковых пропсах и состоянии.

Для чего нужны чистые компоненты и чем они лучше? Чистые компоненты имеют улучшенную производительность за счет поверхностного сравнения пропсов и состояния.

**Для функциональных и для классовых компонентов**

За это отвечает `React.memo()` - компонент высшего порядка.
По умолчанию сравнение происходит поверхностное. Поверхностное сравнение происходит при помощи оператора `===`
##
</details>

<details>
<summary>23. Что такое Lazy loading - ленивая загрузка?</summary>

##
`Lazy loading` - ленивая загрузка, для того чтобы загружать очередной бандл по требованию. Эта оптимизация полезна т.к. не все части приложения могут пригодится сразу же. Таким образом мы можем ускорить загрузку сайта за счет меньшего размера бандла.

Бандлы - это результат работы работы сборщиков проекта (`Webpack`). Сама сборка - это процесс выявления импортированных файлов и объединения их в один файл (часто называемый "bundle" или "бандл"). Этот бандл после подключения на веб-страницу загружает приложение.

Однако нужно следить за размером бандла - любая подключенная библиотека добавляет лишний килобайты. И загрузка может занять слишком много времени. При помощи сборщиков проекта можно создавать несколько бандлов и загружать их по мере необходимости. Общий размер кода не уменьшится (он будет разделен на несколько частей) - однако начальная загрузка будет быстрее.

- React.lazy

```js
const OtherComponent = React.lazy(() => import('./OtherComponent'))
```

Она автоматически загрузит бандл, содержащий OtherComponent, когда этот компонент будет впервые отрендерен.

`React.lazy` принимает функцию, которая должна вызвать динамический `import()`. Результатом возвращённого `Promise` является модуль, который экспортирует по умолчанию `React-компонент` (export default).

- Suspense

Компонент с ленивой загрузкой должен рендериться внутри компонента Suspense, который позволяет нам показать запасное содержимое (например, индикатор загрузки) пока происходит загрузка ленивого компонента.

- Предохранители (error boundary)

Если какой-то модуль не загружается (например, из-за сбоя сети), это вызовет ошибку. Можно обрабатывать эти ошибки для улучшения пользовательского опыта с помощью предохранителей.
##
</details>

---

# Redux

<details>
<summary>1. В каких случаях можно использовать локальное состояние, а в каких
лучше использовать глобальный State?</summary>

##
Локальное состояние рекомендуется использовать в тех случаях, когда оно
используется только в рамках 1го компонента и не планируется передавать его в
других компоненты. Также локальное состояние используется в компоненте какогото отдельного элемента списка. Если же декомпозиция на компоненты предполагает
вложенность с передачей данных по иерархии, то лучше использовать global state
##
</details>

<details>
<summary>2. Что такое редьюсер и какие параметры он принимает?</summary>

##
Reducer это чистая функция, которая принимает параметрами state и action.
Внутри редюсера мы отслеживаем тип полученного actions и в зависимости от него
мы изменяем состояние и возвращаем новый объект состояния.
##
</details>

<details>
<summary>3. Что такое экшен и как изменить состояние?</summary>

##
Action - это простой js объект, у которого обязательно должно быть поле с типом.
```js
{type: “SET_PAGE”}
```
Также опционально можно добавить какие-то данные. Для того что бы
изменить состояние необходимо вызвать функцию dispatch, в которую передаем
action.
##
</details>

<details>
<summary>4. Асинхронные actions в redux с помощью thunk?</summary>

##
Для того, чтобы использовать redux thunk необходимо подключить его как
middleware. Action creators должны возвращать не просто объект, а функцию, которая
параметром принимает dispatch.
##
</details>

<details>
<summary>5. Что такое Flux - архитектура? Какие сущности она имеет?</summary>

##
Flux-архитектура — архитектурный подход или набор шаблонов программирования для построения пользовательского интерфейса веб-приложений, сочетающийся с реактивным программированием и построенный на однонаправленных потоках данных.

Основной отличительной особенностью Flux является односторонняя направленность передачи данных между компонентами Flux-архитектуры. Архитектура накладывает ограничения на поток данных, в частности, исключая возможность обновления состояния компонентов самими собой. Такой подход делает поток данных предсказуемым и позволяет легче проследить причины возможных ошибок в программном обеспечении.

В минимальном варианте Flux-архитектура может содержать три слоя, взаимодействующие по порядку:

- Действия (англ. actions) — выражение событий (часто для действий используются просто имена — строки, содержащие некоторый «глагол»). Диспетчеры передают действия нижележащим компонентам (хранилищам) по одному. Новое действие не передаётся пока предыдущее полностью не обработано компонентами. Действия из-за работы источника действия, например, пользователя, поступают асинхронно, но их диспетчеризация явлется синхронным процессом. Кроме имени (англ. name), действия могут иметь полезную нагрузку (англ. payload), содержащую относящиеся к действию данные.
- Диспетчер/Диспатчер (англ. dispatcher) предназначен для передачи действий хранилищам. В упрощённом варианте диспетчер может вообще не выделяться, как единственный на всё приложение. В диспетчере хранилища регистрируют свои функции обратного вызова (callback) и зависимости между хранилищами.
- Хранилище (англ. store) является местом, где сосредоточено состояние (англ. state) приложения. Остальные компоненты, согласно Flux, не имеют значимого (с точки зрения архитектуры) состояния. Изменение состояния хранилища происходит строго на основе данных действия и старого состояния хранилища при помощи чистых функций.
- Представление (англ. view) — компонент, обычно отвечающий за выдачу информации пользователю. Во Flux-архитектуре, которая может технически не касаться внутреннего устройства представлений вообще, это — конечная точка потоков данных. Для информационной архитектуры важно только, что данные попадают в систему (то есть, обратно в хранилища) только через действия.
##
</details>

<details>
<summary>6. Зачем нужен Redux Toolkit если есть Redux?</summary>

##
Он был разработан для решения трех главных проблем:

- Слишком сложная настройка хранилища (store)
- Для того, чтобы заставить Redux делать что-то полезное, приходится использовать дополнительные пакеты
- Слишком много шаблонного кода (boilerplate)
##
</details>

<details>
<summary>7. Что такое Redux?</summary>

##
`Redux` - это стэйт менеджер для JS приложений. Он может работать не только в `React` приложениях. Он хранит состояние в дереве объектов внутри единого стора. Единственная возможность изменить состояние - отправить `action`. `Action` - это объект, который описывает действие (он отвечает на вопрос: "Что я хочу изменить в состоянии?"). Далее `action` попадает в `reducer`, где описано, как состояние должно быть изменено. (`reducer` отвечает на вопрос: "Как я хочу изменить стэйт?").
##
</details>

<details>
<summary>8. Отличия MobX и Redux</summary>

##
- `Redux` использует `JS`-объект в качестве структуры данных для хранения данных состояния. И отслеживание изменений происходит явно вручную. `MobX` использует `observables`, и чтобы следить за изменениями используются неявные подписки.
- `Redux` использует чистые функции - очевидные изменения состояния. В `MobX` сложнее отследить изменения и сложнее дебажить.
- В `Mobx` может быть больше одного стора, в `Redux` один большой стор.
##
</details>

---

# TypeScript

<details>
<summary>1. В чем разница между any и unknown?</summary>

##
Значения, аннотированные с помощью `any` или `unknown`, могут иметь любой тип. Разница между этими специальными типами состоит в том, что `unknown` не допускает выполнения операций (к примеру различные методы) со значением до проверки его типа. Чтобы работать со значение нужно явно в далее в коде уточнить его тип. А `any` все ровно это не вызовет ошибку `TypeScript`, если мы захотим вызвать какой либо метод у этой переменной.
##
</details> 

---

# Next.js

<details>
<summary>1. В чем разница между React и Next.js?</summary>

##
**Next.js** — фреймворк, использующий библиотеку `React`. Главное его отличие от «чистого» `React` — в способе рендера конечных веб-страниц.Если `React` загружает минимальный `HTML` и зачастую большой бандл `JS` (иногда разделенный между страницами на модули), то `Next.js` использует `Server Side Rendering` — формирование первоначального `HTML` на стороне сервера, используя тот же самый `React`.

Работа **Next.js** следует шести основным принципам:

1. Работа без настройки. Использование файловой системы в качестве API
2. Только `JavaScript`. Все является функциями
3. Автоматический `Server Side Rendering` и `code-splitting`
5. Механизм получения данных определяется разработчиком
6. Предзагрузка для увеличения производительности
7. Простой деплой и развертывание

**Next.js**:

1. Браузер делает запрос на страницу с информацией о товаре, например, `/product/1`.
2. Сервер получает запрос, загружает необходимые данные о товаре с другого сервера, формирует `HTML` на основе полученных данных и необходимых в данный момент компонентов `React`.
3. Браузер сразу получает `HTML` с нужной информацией и показывает его пользователю, но `JS` для интерактивности еще не загружен.
4. Подгрузка `JS` происходит после этого в фоновом режиме, после чего встраивается уже в имеющийся `HTML`-код — этот процесс называется `hydration`.

Как этот процесс выглядит на **Next.js**

```js
import Head from 'next/head'
import getProductData from "...";

export async function getServerSideProps(context) {
  const product = getProductData(context.params.id);

  return {
    props: {
      product
    },
  };
}

export default function Product({ product }) {
  return (
    <div>
      <Head>
        <title>Купить {product.name}</title>
      </Head>
      <main>
        <img src={product.image} alt="Product image" />
        <h1>{product.name}</h1>
        <p>{product.description}</p>
      </main>
    </div>
  )
}
```
**React**:

1. Браузер делает запрос на страницу с информацией о товаре, например, `/product/1`.
2. Сервер возвращает минимальный `HTML`-файл, в котором прописан импорт `JS`-файла, использующего `React`.
3. После загрузки HTML начинается загрузка `JS`.
4. Только после загрузки `JS`-файла происходит создание необходимых `DOM`-элементов, загрузка данных с сервера и отображение полезного контента.

Как этот процесс выглядит на **React**:

```js
import { Helmet } from "react-helmet";
import getProductData from "...";
import { useParams } from "react-router-dom";
import { useEffect, useState } from "react";

export const Product = () => {
  const { productId } = useParams();
  const [product, setProduct] = useState(null);

  useEffect(() => {
    getProductData(productId)
      .then(product => setProduct(product));
  }, [productId]);

  if (!product) {
    return <div>Загрузка</div>
  }

  return (
    <div>
      <Helmet>
        <title>Купить {product.name}</title>
      </Helmet>
      <main>
        <img src={product.image} alt="Product image" />
        <h1>{product.name}</h1>
        <p>{product.description}</p>
      </main>
    </div>
  )
}
```
##
</details> 
